<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="UTF-8">
    <!-- CHANGE (cleanup): deduped OG/Twitter meta tags; fixed og:image:type to match asset -->
    <!-- Social preview metadata -->
    <meta property="og:title" content="Tater's Adventure Through London">
    <meta property="og:description" content="An endless runner about helping a lost dog find his way home. Built in collaboration with AI.">
    <meta property="og:image" content="https://patricstar21.github.io/tatersadventure/preview.jpg">
    <meta property="og:image:secure_url" content="https://patricstar21.github.io/tatersadventure/preview.jpg">
    <meta property="og:image:type" content="image/jpeg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:url" content="https://patricstar21.github.io/tatersadventure/">
    <meta property="og:type" content="website">
    <meta property="fb:app_id" content="1234567890">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Tater's Adventure Through London">
    <meta name="twitter:description" content="An endless runner about helping a lost dog find his way home. Built in collaboration with AI.">
    <meta name="twitter:image" content="https://patricstar21.github.io/tatersadventure/preview.jpg">

    <!-- Favicon -->
    <link rel="icon" href="favicon.ico?v=1.1">
    <link rel="apple-touch-icon" href="preview.jpg">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="description" content="A small endless runner about helping a lost dog find his way home through London.">
    <title>Tater's Adventure Through London</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            position: fixed;
            touch-action: manipulation;
        }

        body {
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            background: #87A5B8;
            font-family: 'Fredoka One', 'Georgia', serif;
        }

        .game-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .sky {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 70%;
            background: linear-gradient(180deg, #6A8FA8 0%, #8AACBE 30%, #A8C4D4 60%, #C8DDE8 100%);
        }

        .clouds {
            position: absolute;
            top: 20px;
            left: 0;
            width: 200%;
            height: 140px;
            animation: scroll-clouds 60s linear infinite;
        }
        .clouds.paused { animation-play-state: paused; }
        @keyframes scroll-clouds {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }
        .cloud {
            position: absolute;
            background: rgba(255,255,255,0.9);
            border-radius: 50px;
        }

        .landmarks-far {
            position: absolute;
            bottom: 32%;
            left: 0;
            width: 200%;
            height: 180px;
            animation: scroll-far 80s linear infinite;
        }
        .landmarks-far.paused { animation-play-state: paused; }
        @keyframes scroll-far {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }

        .landmarks-mid {
            position: absolute;
            bottom: 28%;
            left: 0;
            width: 200%;
            height: 160px;
            animation: scroll-mid 50s linear infinite;
        }
        .landmarks-mid.paused { animation-play-state: paused; }
        @keyframes scroll-mid {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }

        .park-elements {
            position: absolute;
            bottom: 22%;
            left: 0;
            width: 200%;
            height: 130px;
            animation: scroll-park 30s linear infinite;
        }
        .park-elements.paused { animation-play-state: paused; }
        @keyframes scroll-park {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }

        .grass {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30%;
            background: linear-gradient(180deg, #5A9A4A 0%, #4A8A3A 30%, #3A7A2A 100%);
        }

        .path {
            position: absolute;
            bottom: 5%;
            left: 0;
            width: 200%;
            height: 60px;
            background: linear-gradient(180deg, #D4C8B8 0%, #C4B8A8 30%, #B4A898 70%, #A49888 100%);
            border-top: 3px solid #8A7A6A;
            border-bottom: 3px solid #7A6A5A;
            animation: scroll-path 8s linear infinite;
        }
        .path.paused { animation-play-state: paused; }
        @keyframes scroll-path {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }

        .tater-container {
            position: absolute;
            left: 10%;
            bottom: 9%;
            z-index: 100;
            transition: bottom 0.05s linear;
        }

        /* Visual pass - Tater with consistent storybook shadow */
        .tater {
            width: 100px;
            height: 75px;
            filter: drop-shadow(1px 2px 3px rgba(0,0,0,0.4)) drop-shadow(0 0 1px rgba(0,0,0,0.25));
        }
        @media (min-width: 768px) {
            .tater { width: 120px; height: 90px; }
        }
        .tater.running {
            animation: tater-run 0.2s ease-in-out infinite;
        }
        @keyframes tater-run {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-4px); }
        }
        .tater.hurt {
            animation: tater-hurt 0.5s ease-out;
        }
        /* Visual pass - hurt animation with consistent base shadow */
        @keyframes tater-hurt {
            0%, 100% { filter: drop-shadow(1px 2px 3px rgba(0,0,0,0.4)) drop-shadow(0 0 1px rgba(0,0,0,0.25)); }
            20%, 60% { filter: drop-shadow(0 0 15px #ff4444) brightness(1.2); transform: translateX(-4px); }
            40%, 80% { filter: drop-shadow(0 0 10px #ff4444) brightness(0.9); transform: translateX(4px); }
        }
        .tater.healed {
            animation: tater-heal 0.5s ease-out;
        }
        /* Visual pass - heal animation with consistent base shadow */
        @keyframes tater-heal {
            0%, 100% { filter: drop-shadow(1px 2px 3px rgba(0,0,0,0.4)) drop-shadow(0 0 1px rgba(0,0,0,0.25)); }
            50% { filter: drop-shadow(0 0 20px #44ff44) brightness(1.2); transform: scale(1.08); }
        }

        /* ================================================================
           EMOTION v1 CSS (single source of truth) â€” Priority 3
           States: defeated, weary, tired, settled, hopeful
           Stacking: .tater.defeated.hopeful blends both transforms
           ================================================================ */

        /* Game-over polish - Part C: Tater's defeated state */
        .tater.defeated {
            animation: none !important;
            transform: translateY(8px) rotate(-5deg);
            filter: drop-shadow(1px 2px 3px rgba(0,0,0,0.4)) brightness(0.85) saturate(0.7);
            transition: transform 0.4s ease-out, filter 0.4s ease-out;
        }
        .tater.defeated .tater-tail,
        .tater.defeated .tater-ear-left,
        .tater.defeated .tater-ear-right,
        .tater.defeated .tater-tongue {
            animation: none !important;
        }
        .tater.defeated .tater-tail {
            transform: rotate(-15deg) !important;
        }
        .tater.defeated .tater-tongue {
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        body.reduce-motion .tater.defeated {
            transition: none !important;
        }

        /* Priority 3: Emotional feedback - Settled state (milestone reached) */
        /* Brief calm beat: posture relaxes, tail wag slows, breathing steadies */
        .tater.settled {
            animation: tater-settle 0.8s ease-out forwards;
        }
        @keyframes tater-settle {
            0% { transform: translateY(0); }
            30% { transform: translateY(1px) scale(1.01); }
            60% { transform: translateY(0) scale(1.005); }
            100% { transform: translateY(0) scale(1); }
        }
        .tater.settled .tater-tail {
            animation: tail-wag-slow 0.6s ease-in-out infinite;
        }
        @keyframes tail-wag-slow {
            0%, 100% { transform: rotate(-4deg); }
            50% { transform: rotate(6deg); }
        }
        body.reduce-motion .tater.settled {
            animation: none !important;
        }
        body.reduce-motion .tater.settled .tater-tail {
            animation: none !important;
        }

        /* Priority 3: Emotional feedback - Weary state (mid-late run, subtle fatigue) */
        /* Subtler than tired: slightly reduced bounce, marginally slower tail */
        .tater.weary.running {
            animation: tater-run-weary 0.22s ease-in-out infinite;
        }
        @keyframes tater-run-weary {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }
        .tater.weary .tater-tail {
            animation: tail-wag-weary 0.4s ease-in-out infinite;
        }
        @keyframes tail-wag-weary {
            0%, 100% { transform: rotate(-6deg); }
            50% { transform: rotate(8deg); }
        }
        body.reduce-motion .tater.weary.running {
            animation: none !important;
        }
        body.reduce-motion .tater.weary .tater-tail {
            animation: none !important;
        }

        /* Priority 3: Emotional feedback - Tired state (late-run, determined) */
        /* Reduced bounce, slower pant, drooping ears, slower tail */
        .tater.tired.running {
            animation: tater-run-tired 0.25s ease-in-out infinite;
        }
        @keyframes tater-run-tired {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-2px); }
        }
        .tater.tired .tater-tail {
            animation: tail-wag-tired 0.5s ease-in-out infinite;
        }
        @keyframes tail-wag-tired {
            0%, 100% { transform: rotate(-5deg); }
            50% { transform: rotate(5deg); }
        }
        .tater.tired .tater-ear-left {
            animation: ear-droop-left 0.4s ease-in-out infinite;
        }
        .tater.tired .tater-ear-right {
            animation: ear-droop-right 0.4s ease-in-out infinite 0.05s;
        }
        @keyframes ear-droop-left {
            0%, 100% { transform: rotate(2deg) translateY(1px); }
            50% { transform: rotate(0deg) translateY(2px); }
        }
        @keyframes ear-droop-right {
            0%, 100% { transform: rotate(-2deg) translateY(1px); }
            50% { transform: rotate(0deg) translateY(2px); }
        }
        .tater.tired.running .tater-tongue {
            animation: tongue-pant-tired 0.6s ease-in-out infinite;
        }
        @keyframes tongue-pant-tired {
            0%, 100% { transform: translateY(0) scaleY(1); }
            50% { transform: translateY(1px) scaleY(1.05); }
        }
        body.reduce-motion .tater.tired.running {
            animation: none !important;
        }
        body.reduce-motion .tater.tired .tater-tail,
        body.reduce-motion .tater.tired .tater-ear-left,
        body.reduce-motion .tater.tired .tater-ear-right,
        body.reduce-motion .tater.tired.running .tater-tongue {
            animation: none !important;
        }

        /* Priority 3: Emotional feedback - Hopeful state (game-over, subtle hope) */
        /* Very subtle lift of head/posture after defeat, implying "we'll try again" */
        .tater.hopeful {
            animation: tater-hopeful 0.8s ease-out forwards;
        }
        @keyframes tater-hopeful {
            0% { transform: translateY(8px) rotate(-5deg); }
            60% { transform: translateY(6px) rotate(-3deg); }
            100% { transform: translateY(7px) rotate(-4deg); }
        }
        .tater.hopeful .tater-tail {
            animation: tail-hopeful 1.2s ease-in-out;
        }
        @keyframes tail-hopeful {
            0%, 100% { transform: rotate(-15deg); }
            50% { transform: rotate(-8deg); }
        }
        body.reduce-motion .tater.hopeful {
            animation: none !important;
            transform: translateY(7px) rotate(-4deg);
        }
        body.reduce-motion .tater.hopeful .tater-tail {
            animation: none !important;
        }

        /* Priority 3: Defeated + Hopeful stacking - when hopeful is added after defeated */
        /* Override the defeated !important to allow hopeful animation to play */
        .tater.defeated.hopeful {
            animation: tater-hopeful 0.8s ease-out forwards !important;
        }
        .tater.defeated.hopeful .tater-tail {
            animation: tail-hopeful 1.2s ease-in-out !important;
        }
        body.reduce-motion .tater.defeated.hopeful {
            animation: none !important;
            transform: translateY(7px) rotate(-4deg);
        }
        body.reduce-motion .tater.defeated.hopeful .tater-tail {
            animation: none !important;
        }

        /* Tater enhanced animations - tail wag */
        .tater .tater-tail {
            transform-origin: 20px 35px;
            animation: tail-wag 0.3s ease-in-out infinite;
        }
        @keyframes tail-wag {
            0%, 100% { transform: rotate(-8deg); }
            50% { transform: rotate(12deg); }
        }

        /* Tater enhanced animations - ear flop */
        .tater .tater-ear-left {
            transform-origin: 92px 20px;
            animation: ear-flop-left 0.25s ease-in-out infinite;
        }
        .tater .tater-ear-right {
            transform-origin: 115px 18px;
            animation: ear-flop-right 0.25s ease-in-out infinite 0.05s;
        }
        @keyframes ear-flop-left {
            0%, 100% { transform: rotate(0deg) translateY(0); }
            50% { transform: rotate(-3deg) translateY(-1px); }
        }
        @keyframes ear-flop-right {
            0%, 100% { transform: rotate(0deg) translateY(0); }
            50% { transform: rotate(3deg) translateY(-1px); }
        }

        /* Tater enhanced animations - blink */
        .tater .tater-eyelid-left,
        .tater .tater-eyelid-right {
            animation: tater-blink 4s ease-in-out infinite;
        }
        .tater .tater-eyelid-right {
            animation-delay: 0.05s;
        }
        @keyframes tater-blink {
            0%, 92%, 100% { transform: scaleY(0); }
            94%, 98% { transform: scaleY(1); }
        }

        /* Tater enhanced animations - tongue pant */
        .tater.running .tater-tongue {
            animation: tongue-pant 0.4s ease-in-out infinite;
        }
        @keyframes tongue-pant {
            0%, 100% { transform: translateY(0) scaleY(1); }
            50% { transform: translateY(2px) scaleY(1.1); }
        }

        /* Tater enhanced - idle breathing when not running */
        .tater:not(.running):not(.hurt):not(.healed) {
            animation: tater-idle 2s ease-in-out infinite;
        }
        @keyframes tater-idle {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .shadow {
            width: 60px;
            height: 10px;
            background: radial-gradient(ellipse, rgba(0,0,0,0.3) 0%, transparent 70%);
            border-radius: 50%;
            margin: 0 auto;
            margin-left: 20px;
            transition: transform 0.05s, opacity 0.05s;
        }

        .obstacles {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .obstacle, .powerup {
            position: absolute;
            z-index: 50;
        }

        /* Visual pass - inner sprite wrapper with storybook shadow */
        .sprite {
            width: 100%;
            height: 100%;
            /* Visual pass - consistent storybook shadow: soft offset + subtle outline glow */
            filter: drop-shadow(1px 2px 2px rgba(0,0,0,0.35)) drop-shadow(0 0 1px rgba(0,0,0,0.2));
        }

        /* Flying objects polish - spawn-in animation */
        .sprite.spawning {
            animation: sprite-spawn 150ms ease-out forwards;
        }
        @keyframes sprite-spawn {
            0% { opacity: 0; transform: scale(0.7); }
            100% { opacity: 1; transform: scale(1); }
        }

        /* Flying objects polish - entry telegraph (brief attention-getting bob) */
        .sprite.telegraph {
            animation: sprite-telegraph 200ms ease-out;
        }
        /* Visual pass - telegraph animation with consistent shadow */
        @keyframes sprite-telegraph {
            0%, 100% { transform: translateY(0); filter: drop-shadow(1px 2px 2px rgba(0,0,0,0.35)) drop-shadow(0 0 1px rgba(0,0,0,0.2)); }
            50% { transform: translateY(-4px); filter: drop-shadow(1px 2px 2px rgba(0,0,0,0.35)) drop-shadow(0 0 8px rgba(255,200,100,0.5)); }
        }

        /* Flying objects polish - per-type idle animations */

        /* Balloon: gentle sway + vertical bob */
        .sprite.balloon-idle {
            animation: balloon-float 2.5s ease-in-out infinite;
        }
        @keyframes balloon-float {
            0%, 100% { transform: translateY(0) rotate(-2deg); }
            25% { transform: translateY(-3px) rotate(0deg); }
            50% { transform: translateY(-1px) rotate(2deg); }
            75% { transform: translateY(-4px) rotate(0deg); }
        }

        /* Pigeon: subtle flap + bob */
        .sprite.pigeon-idle {
            animation: pigeon-bob 0.6s ease-in-out infinite;
        }
        @keyframes pigeon-bob {
            0%, 100% { transform: translateY(0) scaleY(1); }
            50% { transform: translateY(-2px) scaleY(0.95); }
        }

        /* Thunder cloud: slight jitter */
        .sprite.thunder-idle {
            animation: thunder-jitter 0.15s ease-in-out infinite;
        }
        @keyframes thunder-jitter {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-1px); }
            75% { transform: translateX(1px); }
        }

        /* Vacuum: subtle vibration */
        .sprite.vacuum-idle {
            animation: vacuum-shake 0.08s linear infinite;
        }
        @keyframes vacuum-shake {
            0%, 100% { transform: translateX(0); }
            50% { transform: translateX(1px); }
        }

        /* Cat: subtle tail swish via slight bob */
        .sprite.cat-idle {
            animation: cat-prowl 0.8s ease-in-out infinite;
        }
        @keyframes cat-prowl {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-1px); }
        }

        /* Squirrel: nervous twitch */
        .sprite.squirrel-idle {
            animation: squirrel-twitch 0.4s ease-in-out infinite;
        }
        @keyframes squirrel-twitch {
            0%, 80%, 100% { transform: translateY(0) rotate(0deg); }
            40% { transform: translateY(-2px) rotate(-2deg); }
        }

        /* Skateboard: slight roll wobble */
        .sprite.skateboard-idle {
            animation: skateboard-roll 0.3s ease-in-out infinite;
        }
        @keyframes skateboard-roll {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-1px); }
        }

        /* ROSTER UPDATE: Umbrella - tumbling drift */
        .sprite.umbrella-idle {
            animation: umbrella-tumble 1.5s ease-in-out infinite;
        }
        @keyframes umbrella-tumble {
            0%, 100% { transform: translateY(0) rotate(-5deg); }
            25% { transform: translateY(-4px) rotate(0deg); }
            50% { transform: translateY(-2px) rotate(5deg); }
            75% { transform: translateY(-5px) rotate(2deg); }
        }

        /* ROSTER UPDATE: Frisbee - gentle spin wobble (inner only, no container rotation) */
        .sprite.frisbee-idle {
            animation: frisbee-wobble 0.8s ease-in-out infinite;
        }
        @keyframes frisbee-wobble {
            0%, 100% { transform: translateY(0) scaleX(1); }
            25% { transform: translateY(-2px) scaleX(0.98); }
            50% { transform: translateY(-1px) scaleX(1); }
            75% { transform: translateY(-3px) scaleX(1.02); }
        }

        /* Default idle for others (mailman, vet, cone): subtle presence bob */
        .sprite.default-idle {
            animation: default-bob 1.2s ease-in-out infinite;
        }
        @keyframes default-bob {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-1px); }
        }

        /* Flying objects polish - depth cues: ground shadow for obstacles */
        .obstacle::after {
            content: '';
            position: absolute;
            bottom: -4px;
            left: 10%;
            width: 80%;
            height: 6px;
            background: radial-gradient(ellipse, rgba(0,0,0,0.15) 0%, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
        }

        /* Powerup styling */
        .powerup {
            z-index: 60;
        }

        /* Flying objects polish - bone powerup: gentle float + enhanced glow */
        .sprite.bone-idle {
            animation: bone-float 1.5s ease-in-out infinite, bone-glow 0.5s ease-in-out infinite alternate;
        }
        @keyframes bone-float {
            0%, 100% { transform: translateY(0) rotate(-1deg); }
            50% { transform: translateY(-5px) rotate(1deg); }
        }
        @keyframes bone-glow {
            0% { filter: drop-shadow(0 0 5px #FFD700) drop-shadow(0 0 10px #FFD700); }
            100% { filter: drop-shadow(0 0 12px #FFD700) drop-shadow(0 0 20px #FFEC8B); }
        }

        .ui-top {
            position: fixed;
            top: max(10px, env(safe-area-inset-top));
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 0 max(15px, env(safe-area-inset-left)) 0 max(15px, env(safe-area-inset-right));
            z-index: 500;
        }

        .lives-container {
            display: flex;
            gap: 4px;
            background: rgba(255,252,245,0.95);
            padding: 8px 12px;
            border-radius: 12px;
            border: 2px solid #A08060;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
        }
        .life-bone {
            width: 28px;
            height: 18px;
            transition: all 0.3s ease;
        }
        @media (min-width: 768px) {
            .life-bone { width: 34px; height: 20px; }
            .lives-container { gap: 6px; padding: 10px 16px; }
        }
        .life-bone.lost {
            opacity: 0.2;
            filter: grayscale(1) brightness(1.5);
        }

        .controls {
            display: flex;
            gap: 8px;
        }
        .btn {
            background: linear-gradient(180deg, #FFF8F0 0%, #F0E8E0 100%);
            border: 2px solid #A08060;
            border-radius: 10px;
            padding: 8px 14px;
            font-family: 'Fredoka One', 'Georgia', serif;
            font-size: 14px;
            color: #5A4A3A;
            cursor: pointer;
            box-shadow: 0 3px 8px rgba(0,0,0,0.2);
            transition: all 0.15s ease;
        }
        @media (min-width: 768px) {
            .btn { padding: 10px 20px; font-size: 16px; }
        }
        .btn:hover { transform: translateY(-2px); }
        .btn:active { transform: translateY(1px); }

        .score-display {
            position: fixed;
            top: max(60px, calc(env(safe-area-inset-top) + 50px));
            left: max(15px, env(safe-area-inset-left));
            background: rgba(255,252,245,0.95);
            padding: 8px 16px;
            border-radius: 12px;
            border: 2px solid #A08060;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
            font-size: 14px;
            color: #5A4A3A;
            z-index: 500;
        }
        .score-display span {
            font-size: 22px;
            color: #3A7A3A;
        }
        @media (min-width: 768px) {
            .score-display { font-size: 16px; padding: 10px 20px; }
            .score-display span { font-size: 26px; }
        }

        .game-title {
            position: fixed;
            top: max(12px, env(safe-area-inset-top));
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Fredoka One', cursive;
            font-size: 12px;
            color: #4A6A4A;
            text-shadow: 2px 2px 0 #fff, -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff;
            z-index: 500;
            white-space: nowrap;
        }
        @media (min-width: 500px) {
            .game-title { font-size: 16px; }
        }
        @media (min-width: 768px) {
            .game-title { font-size: 24px; }
        }

        /* Mobile UI - responsive header and compact controls */
        /* CHANGE (cleanup): removed conflicting 480px mobile HUD rules; 520px block is source of truth */
        /* .game-title and .score-display positioning moved to @media (max-width: 520px) block */
        @media (max-width: 480px) {
            .ui-top {
                padding: 0 max(8px, env(safe-area-inset-right)) 0 max(8px, env(safe-area-inset-left));
            }
            .lives-container {
                padding: 6px 8px;
                gap: 2px;
            }
            .life-bone {
                width: 22px;
                height: 14px;
            }
            .controls {
                gap: 6px;
            }
            /* Mobile UI - hide text labels, show icons only */
            .btn {
                min-width: 44px;
                min-height: 44px;
                padding: 10px;
                font-size: 18px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            .btn-label { display: none; }
            .btn-icon { display: inline; }
            /* Mobile UI - more menu styling */
            .mobile-more-btn {
                display: flex;
                align-items: center;
                justify-content: center;
            }
            .mobile-menu {
                display: none;
                position: absolute;
                top: 100%;
                right: 0;
                margin-top: 8px;
                background: rgba(255,252,245,0.98);
                border: 2px solid #A08060;
                border-radius: 12px;
                box-shadow: 0 4px 16px rgba(0,0,0,0.25);
                padding: 10px;
                flex-direction: column;
                gap: 10px;
                z-index: 600;
            }
            .mobile-menu.show {
                display: flex;
            }
            .mobile-menu .btn {
                width: 100%;
                min-width: 130px;
                justify-content: flex-start;
                padding: 12px 16px;
            }
            .mobile-menu .btn-label { display: inline; }
            .mobile-menu .btn-icon { margin-right: 10px; }
            /* REMOVED: .score-display positioning - now in 520px block */
            /* Mobile UI - hide hint on very small screens */
            .hint {
                font-size: 10px;
                bottom: 8%;
            }
        }
        /* Mobile UI - desktop shows labels, hides mobile elements */
        @media (min-width: 481px) {
            .btn-icon { display: none; }
            .btn-label { display: inline; }
            .mobile-more-btn { display: none !important; }
            .mobile-menu { display: none !important; }
            #resetBtnMobile { display: none !important; }
        }
        /* Mobile UI - mobile hides desktop reset button */
        @media (max-width: 480px) {
            #resetBtn { display: none !important; }
        }
        /* Mobile UI - Extra compact breakpoint for very small screens (360px and below) */
        @media (max-width: 360px) {
            .ui-top {
                padding: 0 max(4px, env(safe-area-inset-right)) 0 max(4px, env(safe-area-inset-left));
            }
            .lives-container {
                padding: 4px 6px;
                gap: 1px;
                border-radius: 8px;
            }
            .life-bone {
                width: 18px;
                height: 12px;
            }
            .controls {
                gap: 4px;
            }
            .btn {
                min-width: 40px;
                min-height: 40px;
                padding: 8px;
                font-size: 16px;
            }
            /* REMOVED: .game-title and .score-display rules - now in consolidated 360px block below */
            /* Compact hint */
            .hint {
                font-size: 9px;
                padding: 6px 12px;
            }
            /* Compact mobile menu */
            .mobile-menu {
                padding: 8px;
                gap: 8px;
            }
            .mobile-menu .btn {
                min-width: 110px;
                padding: 10px 12px;
                font-size: 14px;
            }
        }
        /* Mobile UI - controls wrapper for menu positioning */
        .controls-wrapper {
            position: relative;
            display: flex;
            align-items: flex-start;
        }

        .jump-indicator {
            position: fixed;
            bottom: 20%;
            left: 8%;
            width: 10px;
            height: 0;
            max-height: 60px;
            background: linear-gradient(180deg, #90EE90 0%, #32CD32 100%);
            border-radius: 5px;
            z-index: 150;
            box-shadow: 0 0 10px rgba(50,205,50,0.5);
            transition: height 0.03s linear;
        }

        .hint {
            position: fixed;
            bottom: max(15px, env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,252,245,0.95);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 12px;
            color: #5A4A3A;
            z-index: 500;
            border: 2px solid #A08060;
            white-space: nowrap;
            opacity: 1;
            transition: opacity 0.4s ease-out;
        }
        .hint.hidden {
            opacity: 0;
            pointer-events: none;
        }
        /* Onboarding - Toast mode for temporary tips */
        .hint.toast {
            animation: toast-appear 0.3s ease-out;
        }
        .hint.toast-out {
            animation: toast-disappear 0.4s ease-out forwards;
        }
        @keyframes toast-appear {
            from { opacity: 0; transform: translateX(-50%) translateY(10px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        @keyframes toast-disappear {
            from { opacity: 1; transform: translateX(-50%) translateY(0); }
            to { opacity: 0; transform: translateX(-50%) translateY(-10px); }
        }
        body.reduce-motion .hint.toast,
        body.reduce-motion .hint.toast-out {
            animation: none !important;
        }
        @media (min-width: 768px) {
            .hint { font-size: 14px; padding: 12px 28px; }
        }

        .damage-flash, .heal-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            z-index: 400;
            transition: opacity 0.1s;
        }
        .damage-flash { background: rgba(255,80,80,0.3); }
        .heal-flash { background: rgba(80,255,80,0.25); }
        .damage-flash.show, .heal-flash.show { opacity: 1; }

        /* Step 3 juice - screen shake animation */
        .game-container.shake {
            animation: screen-shake 100ms ease-out;
        }
        @keyframes screen-shake {
            0%, 100% { transform: translateX(0) translateY(0); }
            20% { transform: translateX(-3px) translateY(1px); }
            40% { transform: translateX(3px) translateY(-1px); }
            60% { transform: translateX(-2px) translateY(1px); }
            80% { transform: translateX(2px) translateY(-1px); }
        }

        /* Step 3 juice - floating text for heal */
        .float-text {
            position: absolute;
            font-family: 'Fredoka One', cursive;
            font-size: 18px;
            color: #44DD44;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3), 0 0 8px rgba(68,255,68,0.5);
            pointer-events: none;
            z-index: 200;
            animation: float-up 600ms ease-out forwards;
        }
        @keyframes float-up {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-40px) scale(1.2); }
        }

        /* Step 3 juice - bone pop animation on collect */
        .sprite.collected {
            animation: bone-pop 150ms ease-out forwards !important;
        }
        @keyframes bone-pop {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.8; }
            100% { transform: scale(0); opacity: 0; }
        }

        /* CHANGE (mobile): center game-over modal reliably on iOS */
        /* Overlay show/hide: .overlay.show is the SINGLE source of truth for display toggle */
        .overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.7);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 1000;

    /* iOS centering stability */
    min-height: 100vh;
    min-height: 100svh;
    padding: max(20px, env(safe-area-inset-top))
             max(16px, env(safe-area-inset-right))
             max(20px, env(safe-area-inset-bottom))
             max(16px, env(safe-area-inset-left));
}

.overlay.show { display: flex; }

        /* Single source of truth for overlay visibility */
        /* CHANGE (mobile): center game-over modal reliably on iOS */
        .overlay-content {
            background: linear-gradient(180deg, #FFF8F0 0%, #F0E8E0 100%);
            padding: 30px 40px;
            border-radius: 20px;
            border: 3px solid #A08060;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
            max-width: 90%;
            /* Mobile: prevent clipping on small screens */
            max-height: calc(100svh - 40px);
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        @media (min-width: 768px) {
            .overlay-content { padding: 45px 65px; max-height: none; overflow-y: visible; }
        }
        .overlay-title {
            font-family: 'Fredoka One', cursive;
            font-size: 32px;
            color: #4A6A4A;
            margin-bottom: 12px;
        }
        @media (min-width: 768px) {
            .overlay-title { font-size: 40px; }
        }
        .overlay-score {
            font-size: 18px;
            color: #5A4A3A;
            margin-bottom: 20px;
            line-height: 1.5;
        }
        .overlay-btn {
            background: linear-gradient(180deg, #6AB06A 0%, #5A9A5A 100%);
            color: white;
            border: 3px solid #4A8A4A;
            padding: 14px 40px;
            font-family: 'Fredoka One', cursive;
            font-size: 20px;
            border-radius: 12px;
            cursor: pointer;
            margin: 8px;
            transition: all 0.15s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
        }
        .overlay-btn:hover, .overlay-btn:active {
            transform: scale(1.05);
            background: linear-gradient(180deg, #7AC07A 0%, #6AB06A 100%);
        }
        .overlay-btn.secondary {
            background: linear-gradient(180deg, #8A8A9A 0%, #6A6A7A 100%);
            border-color: #5A5A6A;
            font-size: 16px;
            padding: 10px 28px;
        }
        .overlay-btn.secondary:hover, .overlay-btn.secondary:active {
            background: linear-gradient(180deg, #9A9AAA 0%, #7A7A8A 100%);
        }

        /* Step 4 tutorial - tutorial overlay styling */
        .tutorial-tips {
            text-align: left;
            margin: 15px 0 20px 0;
        }
        .tutorial-tip {
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 12px 0;
            font-size: 16px;
            color: #5A4A3A;
        }
        @media (min-width: 768px) {
            .tutorial-tip { font-size: 18px; }
        }
        .tutorial-tip-icon {
            font-size: 24px;
            min-width: 32px;
            text-align: center;
        }

        /* Share polish - About button styling */
        .about-btn {
            position: fixed;
            bottom: max(15px, env(safe-area-inset-bottom));
            right: max(15px, env(safe-area-inset-right));
            width: 36px;
            height: 36px;
            background: rgba(255,252,245,0.9);
            border: 2px solid #A08060;
            border-radius: 50%;
            font-family: 'Georgia', serif;
            font-size: 18px;
            font-style: italic;
            font-weight: bold;
            color: #5A4A3A;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }
        .about-btn:hover { transform: scale(1.1); }
        .about-btn:active { transform: scale(0.95); }
        @media (max-width: 480px) {
            .about-btn {
                width: 32px;
                height: 32px;
                font-size: 16px;
            }
        }

        /* Share polish - Version string styling */
        .version-string {
            position: fixed;
            bottom: max(8px, env(safe-area-inset-bottom));
            left: max(10px, env(safe-area-inset-left));
            font-family: 'Fredoka One', cursive;
            font-size: 10px;
            color: rgba(90, 74, 58, 0.5);
            z-index: 100;
            pointer-events: none;
        }

        /* Share polish - About modal content styling */
        .about-content {
            max-width: 320px;
        }
        .about-description {
            font-size: 16px;
            color: #5A4A3A;
            margin: 15px 0;
            line-height: 1.5;
        }
        .about-credits {
            font-size: 14px;
            color: #7A6A5A;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #D0C0B0;
        }
        .about-credits strong {
            color: #5A4A3A;
        }
        .about-dedication {
            font-style: italic;
            margin-top: 8px;
            color: #8A7A6A;
        }

        /* Accessibility - Settings button styling */
        .settings-btn {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            width: 100%;
        }
        .settings-btn .btn-icon { margin-right: 10px; }

        /* Accessibility - Settings panel styling */
        .settings-content {
            max-width: 340px;
            text-align: left;
        }
        .settings-section {
            margin: 15px 0;
        }
        .settings-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid #D0C0B0;
        }
        .settings-toggle:last-child {
            border-bottom: none;
        }
        .settings-toggle-label {
            font-size: 15px;
            color: #5A4A3A;
        }
        .settings-toggle-desc {
            font-size: 11px;
            color: #8A7A6A;
            margin-top: 2px;
        }
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 28px;
            flex-shrink: 0;
            margin-left: 12px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #C0B0A0;
            border-radius: 28px;
            transition: 0.2s;
            border: 2px solid #A08060;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 2px;
            bottom: 2px;
            background: white;
            border-radius: 50%;
            transition: 0.2s;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .toggle-switch input:checked + .toggle-slider {
            background: #6AB06A;
            border-color: #4A8A4A;
        }
        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(22px);
        }
        .settings-keyboard {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #D0C0B0;
        }
        .settings-keyboard-title {
            font-size: 14px;
            font-weight: bold;
            color: #5A4A3A;
            margin-bottom: 8px;
        }
        .settings-keyboard-item {
            font-size: 12px;
            color: #7A6A5A;
            margin: 4px 0;
        }
        .settings-keyboard-item kbd {
            background: #E8E0D8;
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid #C0B0A0;
            font-family: monospace;
            font-size: 11px;
        }

        /* Accessibility - Reduce Motion mode */
        body.reduce-motion .clouds,
        body.reduce-motion .landmarks-far,
        body.reduce-motion .landmarks-mid,
        body.reduce-motion .park-elements,
        body.reduce-motion .path {
            animation-duration: 200s !important;
        }
        body.reduce-motion .tater-tail,
        body.reduce-motion .tater-ear-left,
        body.reduce-motion .tater-ear-right,
        body.reduce-motion .tater-tongue {
            animation: none !important;
        }
        body.reduce-motion .tater-eyelid-left,
        body.reduce-motion .tater-eyelid-right {
            animation: none !important;
        }
        body.reduce-motion .tater.running {
            animation: none !important;
        }
        body.reduce-motion .tater:not(.running):not(.hurt):not(.healed) {
            animation: none !important;
        }
        body.reduce-motion .sprite.spawning,
        body.reduce-motion .sprite.telegraph {
            animation: none !important;
            opacity: 1 !important;
            transform: none !important;
        }
        body.reduce-motion .powerup {
            animation: none !important;
        }
        body.reduce-motion .damage-flash,
        body.reduce-motion .heal-flash {
            animation: none !important;
            opacity: 0 !important;
        }
        body.reduce-motion .float-text {
            animation: none !important;
        }

        /* Accessibility - Reduce Motion: Disable ALL obstacle/sprite idle animations */
        /* This catches balloon-idle, pigeon-idle, thunder-idle, vacuum-idle, cat-idle,
           squirrel-idle, skateboard-idle, umbrella-idle, frisbee-idle, default-idle, etc. */
        body.reduce-motion .sprite[class*="-idle"] {
            animation: none !important;
            transform: none !important;
        }
        /* Accessibility - Reduce Motion: Bone powerup - disable float/glow but keep visible */
        body.reduce-motion .sprite.bone-idle {
            animation: none !important;
            transform: none !important;
            /* Keep a subtle static shadow for visibility, but no pulsing glow */
            filter: drop-shadow(0 0 4px #FFD700) !important;
        }
        /* Accessibility - Reduce Motion: Explicitly disable rapid jitter/shake animations */
        body.reduce-motion .sprite.thunder-idle,
        body.reduce-motion .sprite.vacuum-idle {
            animation: none !important;
            transform: none !important;
            filter: none !important;
        }

        /* Accessibility - High Contrast mode */
        body.high-contrast .game-title {
            background: rgba(0, 0, 0, 0.8) !important;
            color: #FFFFFF !important;
            text-shadow: none !important;
            padding: 6px 14px !important;
            border-radius: 8px !important;
            font-weight: bold;
        }
        body.high-contrast .score-display {
            background: rgba(0, 0, 0, 0.85) !important;
            color: #FFFFFF !important;
            border-color: #FFFFFF !important;
        }
        body.high-contrast .score-display span {
            color: #90FF90 !important;
        }
        body.high-contrast .lives-container {
            background: rgba(0, 0, 0, 0.85) !important;
            border-color: #FFFFFF !important;
        }
        body.high-contrast .hint {
            background: rgba(0, 0, 0, 0.8) !important;
            color: #FFFFFF !important;
            padding: 6px 12px !important;
            border-radius: 6px !important;
        }
        body.high-contrast .btn {
            background: #FFFFFF !important;
            color: #000000 !important;
            border-color: #000000 !important;
            font-weight: bold;
        }
        body.high-contrast .version-string {
            color: rgba(255, 255, 255, 0.7) !important;
        }
        /* Journey framing - High contrast mode compatibility */
        body.high-contrast .location-display {
            background: rgba(0, 0, 0, 0.85) !important;
            color: #FFFFFF !important;
            border-color: #FFFFFF !important;
        }
        body.high-contrast .location-display .location-name {
            color: #90FF90 !important;
        }
        body.high-contrast .location-display .location-progress {
            color: #CCCCCC !important;
        }
        body.high-contrast .milestone-banner {
            background: rgba(0, 0, 0, 0.95) !important;
            color: #FFFFFF !important;
            border-color: #90FF90 !important;
        }
        body.high-contrast .milestone-banner .milestone-label {
            color: #CCCCCC !important;
        }
        body.high-contrast .journey-result {
            background: rgba(0, 100, 0, 0.3) !important;
            border-color: #90FF90 !important;
        }
        body.high-contrast .journey-result .journey-label {
            color: #CCCCCC !important;
        }
        body.high-contrast .journey-result .journey-location {
            color: #90FF90 !important;
        }
        body.high-contrast .journey-result .journey-best {
            color: #AAAAAA !important;
        }
        body.high-contrast .journey-result .journey-best.new-best {
            color: #FFD700 !important;
        }

        /* CHANGE (UI): Visual hierarchy & pacing - Part A: De-emphasize non-critical UI during active play */
        /* Title stays fully visible on all screen sizes; only about/version/extra buttons fade */
        .game-title,
        .about-btn,
        .version-string,
        .controls .btn:not(#pauseBtn):not(#muteBtn) {
            transition: opacity 0.3s ease;
        }
        body.playing .about-btn,
        body.playing .version-string,
        body.playing .controls .btn:not(#pauseBtn):not(#muteBtn) {
            opacity: 0.5;
        }
        /* CHANGE (UI): Desktop title always fully visible during play */
        @media (min-width: 521px) {
            body.playing .game-title {
                opacity: 1 !important;
            }
        }
        /* CHANGE (visual): Reduce HUD noise during play - score slightly softer than journey */
        .score-display {
            transition: opacity 0.3s ease;
        }
        body.playing .score-display {
            opacity: 0.75;
        }
        /* Journey framing - Location display stays prominent (story focus) */
        .location-display {
            transition: opacity 0.3s ease;
        }
        body.playing .location-display {
            opacity: 0.92;
        }
        /* CHANGE (visual): Mute/pause softer during play - Tater is priority */
        body.playing .controls #muteBtn,
        body.playing .controls #pauseBtn {
            opacity: 0.7;
        }
        /* Visual hierarchy & pacing - Reduce motion: instant transitions */
        body.reduce-motion .game-title,
        body.reduce-motion .about-btn,
        body.reduce-motion .version-string,
        body.reduce-motion .controls .btn,
        body.reduce-motion .location-display,
        body.reduce-motion .score-display {
            transition: none !important;
        }

        /* Visual hierarchy & pacing - Part B: Pre-run prompt */
        .start-prompt {
            position: fixed;
            bottom: 25%;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Fredoka One', cursive;
            font-size: 18px;
            color: #5A4A3A;
            background: rgba(255,252,245,0.95);
            padding: 12px 24px;
            border-radius: 20px;
            border: 2px solid #A08060;
            z-index: 500;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        .start-prompt.show {
            opacity: 1;
        }
        body.reduce-motion .start-prompt {
            transition: none !important;
        }
        @media (min-width: 768px) {
            .start-prompt { font-size: 22px; padding: 14px 32px; }
        }

        /* Visual hierarchy & pacing - Part C: Game over overlay fade-in */
        /* CHANGE (cleanup): unified overlay show/hide to single selector to prevent mobile centering drift */
        /* Display toggle uses .overlay.show (generic); #gameOverOverlay adds opacity fade only */
        #gameOverOverlay {
            opacity: 0;
            transition: opacity 0.4s ease;
        }
        #gameOverOverlay.show {
            /* display: flex inherited from .overlay.show - don't duplicate */
            opacity: 1;
        }
        /* Visual hierarchy & pacing - Immediate display for reduce-motion */
        body.reduce-motion #gameOverOverlay {
            transition: none !important;
        }
        body.reduce-motion #gameOverOverlay.show {
            opacity: 1;
        }

        /* Game-over polish - Part B: Cinematic framing (dim/desaturate) */
        .game-container.defeat-cinematic {
            filter: brightness(0.7) saturate(0.5) contrast(1.1);
            transition: filter 0.5s ease-out;
        }
        body.reduce-motion .game-container.defeat-cinematic {
            transition: none !important;
        }

        /* Game-over polish - Part B: Vignette overlay */
        .vignette-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.5) 100%);
            z-index: 450;
            transition: opacity 0.5s ease-out;
        }
        .vignette-overlay.show {
            opacity: 1;
        }
        body.reduce-motion .vignette-overlay {
            transition: none !important;
        }

        /* Game-over polish - Part D: Enhanced overlay styling */
        .game-over-message {
            font-size: 14px;
            color: #7A6A5A;
            margin-bottom: 8px;
            font-style: italic;
        }
        .final-score-display {
            font-size: 42px;
            font-family: 'Fredoka One', cursive;
            color: #4A6A4A;
            margin: 10px 0;
        }
        .best-score-display {
            font-size: 14px;
            color: #8A7A6A;
            margin-bottom: 16px;
        }
        .best-score-display.new-best {
            color: #DAA520;
            font-weight: bold;
        }
        @media (min-width: 768px) {
            .final-score-display { font-size: 52px; }
            .game-over-message { font-size: 16px; }
            .best-score-display { font-size: 16px; }
        }

        /* Journey framing - Location display styling */
        .location-display {
            position: fixed;
            top: max(60px, calc(env(safe-area-inset-top) + 50px));
            right: max(15px, env(safe-area-inset-right));
            background: rgba(255,252,245,0.95);
            padding: 6px 12px;
            border-radius: 10px;
            border: 2px solid #A08060;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
            font-size: 11px;
            color: #5A4A3A;
            z-index: 500;
            text-align: right;
            max-width: 140px;
        }
        .location-display .location-name {
            font-size: 13px;
            font-weight: bold;
            color: #4A6A4A;
            display: block;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .location-display .location-progress {
            font-size: 10px;
            color: #7A6A5A;
            margin-top: 2px;
        }
        @media (min-width: 768px) {
            .location-display { font-size: 12px; padding: 8px 14px; max-width: 160px; }
            .location-display .location-name { font-size: 14px; }
            .location-display .location-progress { font-size: 11px; }
        }
        /* CHANGE (mobile HUD): consolidated single-source mobile layout rules */
        /* Layout: Row 1 = lives + buttons | Row 2 = location (full width) | Row 3 = title | Row 4 = score */
        /* Title during play: opacity 0.85 (subtle but readable). Location: no truncation. */
        @media (max-width: 520px) {
            /* Row 2: Location display as full-width bar below HUD */
            .location-display {
                position: fixed;
                top: max(52px, calc(env(safe-area-inset-top) + 44px));
                left: max(8px, env(safe-area-inset-left));
                right: max(8px, env(safe-area-inset-right));
                max-width: none; /* Remove max-width constraint */
                width: auto;
                padding: 6px 12px;
                font-size: 11px;
                border-radius: 8px;
                text-align: center;
                display: flex;
                justify-content: center;
                align-items: center;
                gap: 8px;
            }
            /* Mobile: location name never truncates - allow wrap */
            .location-display .location-name {
                font-size: 12px;
                white-space: normal;
                overflow: visible;
                text-overflow: clip;
                display: inline;
                line-height: 1.2;
            }
            .location-display .location-progress {
                font-size: 10px;
                display: inline;
                opacity: 0.8;
            }
            /* Mobile: title moves below location bar */
            .game-title {
                top: max(90px, calc(env(safe-area-inset-top) + 82px));
                font-size: 11px;
                background: rgba(255,255,255,0.95);
                padding: 3px 10px;
            }
            /* Mobile: score moves below title */
            .score-display {
                top: max(115px, calc(env(safe-area-inset-top) + 107px));
            }
            /* CHANGE (UI): Mobile title stays readable during play (was 0.3, now 0.85) */
            body.playing .game-title {
                opacity: 0.85;
                font-size: 10px;
            }
            body:not(.playing) .game-title {
                opacity: 1;
            }
        }
        /* CHANGE (mobile HUD): 360px refinements for extra small screens */
        /* Keeps same 2-row layout, just tighter spacing */
        @media (max-width: 360px) {
            .location-display {
                top: max(48px, calc(env(safe-area-inset-top) + 40px));
                padding: 4px 8px;
                font-size: 9px;
                gap: 6px;
            }
            .location-display .location-name { font-size: 10px; }
            .location-display .location-progress { font-size: 8px; }
            .game-title {
                top: max(76px, calc(env(safe-area-inset-top) + 68px));
                font-size: 10px;
                padding: 2px 8px;
            }
            .score-display {
                top: max(98px, calc(env(safe-area-inset-top) + 90px));
                padding: 4px 10px;
                font-size: 11px;
            }
        }

        /* Journey framing - Milestone banner styling */
        .milestone-banner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,252,245,0.98);
            padding: 12px 24px;
            border-radius: 16px;
            border: 3px solid #4A8A4A;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            font-family: 'Fredoka One', cursive;
            font-size: 18px;
            color: #4A6A4A;
            z-index: 550;
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease-out;
        }
        .milestone-banner.show {
            opacity: 1;
        }
        .milestone-banner .milestone-label {
            font-size: 12px;
            color: #7A6A5A;
            font-weight: normal;
        }
        body.reduce-motion .milestone-banner {
            transition: none !important;
        }
        @media (min-width: 768px) {
            .milestone-banner { font-size: 22px; padding: 16px 32px; }
            .milestone-banner .milestone-label { font-size: 14px; }
        }
        @media (max-width: 480px) {
            .milestone-banner { font-size: 16px; padding: 10px 20px; }
            .milestone-banner .milestone-label { font-size: 11px; }
        }

        /* Journey framing - Game over journey display */
        .journey-result {
            margin: 12px 0;
            padding: 12px 16px;
            background: rgba(74, 138, 74, 0.1);
            border-radius: 12px;
            border: 2px solid rgba(74, 138, 74, 0.3);
        }
        .journey-result .journey-label {
            font-size: 12px;
            color: #7A6A5A;
            margin-bottom: 4px;
        }
        .journey-result .journey-location {
            font-size: 20px;
            font-family: 'Fredoka One', cursive;
            color: #4A6A4A;
        }
        .journey-result .journey-best {
            font-size: 12px;
            color: #8A7A6A;
            margin-top: 6px;
        }
        .journey-result .journey-best.new-best {
            color: #DAA520;
            font-weight: bold;
        }
        .journey-encouragement {
            font-size: 13px;
            color: #5A4A3A;
            font-style: italic;
            margin-top: 8px;
        }
        @media (min-width: 768px) {
            .journey-result .journey-location { font-size: 24px; }
            .journey-result .journey-label { font-size: 14px; }
            .journey-result .journey-best { font-size: 14px; }
            .journey-encouragement { font-size: 15px; }
        }

        /* Game-over polish - Part E: Tap overlay to restart hint */
        #gameOverOverlay {
            cursor: pointer;
        }
        #gameOverOverlay .overlay-content {
            cursor: default;
        }
               /* v1.1: keep game-over modal truly centered; hint shouldn't affect flex centering */
        .tap-hint {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: max(12px, env(safe-area-inset-bottom));
            font-size: 11px;
            color: rgba(255,255,255,0.6);
            text-align: center;
            pointer-events: none;
            margin-top: 0; /* no longer in normal flow */
        }


        /* Game-over polish - Part F: Disable screen shake in reduce-motion */
        body.reduce-motion .game-container.shake {
            animation: none !important;
        }
        /* Mobile-only adjustment: lift Tater to avoid thumb occlusion */
@media (max-width: 520px) {
  .tater-container {
    left: 6%;
    bottom: 18%;
  }
}

    </style>
</head>
<body>
    <div class="game-container">
        <div class="sky"></div>
        <div class="clouds" id="clouds"></div>
        <div class="landmarks-far" id="landmarksFar"></div>
        <div class="landmarks-mid" id="landmarksMid"></div>
        <div class="park-elements" id="parkElements"></div>
        <div class="grass"></div>
        <div class="path"></div>
        <div class="obstacles" id="obstacles"></div>

        <div class="tater-container" id="taterContainer">
            <!-- Visual pass - Tater the Corgi with storybook outline filter -->
            <svg class="tater" id="tater" viewBox="0 0 130 95" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <!-- Visual pass - subtle outline filter for storybook look -->
                    <filter id="taterOutline" x="-5%" y="-5%" width="110%" height="110%">
                        <feMorphology in="SourceAlpha" operator="dilate" radius="0.8" result="outline"/>
                        <feFlood flood-color="#8B5A2B" flood-opacity="0.4"/>
                        <feComposite in2="outline" operator="in" result="outlineColor"/>
                        <feMerge>
                            <feMergeNode in="outlineColor"/>
                            <feMergeNode in="SourceGraphic"/>
                        </feMerge>
                    </filter>
                    <!-- Gradients for better shading -->
                    <linearGradient id="furGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" stop-color="#FFAA50"/>
                        <stop offset="50%" stop-color="#E8943C"/>
                        <stop offset="100%" stop-color="#D07828"/>
                    </linearGradient>
                    <linearGradient id="furHighlight" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" stop-color="#FFC870"/>
                        <stop offset="100%" stop-color="#F8A84C"/>
                    </linearGradient>
                    <linearGradient id="bellyGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" stop-color="#FFFFFF"/>
                        <stop offset="100%" stop-color="#FFF0E8"/>
                    </linearGradient>
                    <linearGradient id="noseGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" stop-color="#3A2A20"/>
                        <stop offset="100%" stop-color="#1A0A00"/>
                    </linearGradient>
                </defs>

                <!-- Visual pass - Tail with subtle outline -->
                <g class="tater-tail">
                    <ellipse cx="12" cy="35" rx="13" ry="10" fill="url(#furGradient)" stroke="#B07020" stroke-width="0.8"/>
                    <ellipse cx="14" cy="33" rx="9" ry="6" fill="url(#furHighlight)"/>
                    <ellipse cx="10" cy="32" rx="4" ry="3" fill="#FFC870" opacity="0.6"/>
                </g>

                <!-- Back legs with better shading -->
                <g class="tater-back-legs">
                    <ellipse cx="30" cy="65" rx="10" ry="15" fill="url(#furGradient)">
                        <animate attributeName="ry" values="15;12;15" dur="0.2s" repeatCount="indefinite"/>
                    </ellipse>
                    <ellipse cx="32" cy="63" rx="6" ry="10" fill="url(#furHighlight)" opacity="0.7">
                        <animate attributeName="ry" values="10;8;10" dur="0.2s" repeatCount="indefinite"/>
                    </ellipse>
                    <ellipse cx="30" cy="78" rx="9" ry="5" fill="url(#bellyGradient)"/>
                    <path d="M 23 78 Q 30 82 37 78" stroke="#E8D0C0" stroke-width="1" fill="none" opacity="0.5"/>
                </g>

                <!-- Visual pass - Body with subtle outline -->
                <ellipse cx="55" cy="46" rx="36" ry="23" fill="url(#furGradient)" stroke="#A06018" stroke-width="1"/>
                <ellipse cx="58" cy="43" rx="28" ry="17" fill="url(#furHighlight)"/>
                <ellipse cx="50" cy="40" rx="12" ry="8" fill="#FFC870" opacity="0.4"/>

                <!-- White chest/belly with soft gradient -->
                <ellipse cx="78" cy="53" rx="23" ry="18" fill="url(#bellyGradient)"/>
                <ellipse cx="80" cy="50" rx="17" ry="13" fill="#FFFFFF"/>
                <ellipse cx="82" cy="48" rx="10" ry="8" fill="#FFFFFF" opacity="0.8"/>

                <!-- Front legs with shading -->
                <g class="tater-front-legs">
                    <ellipse cx="88" cy="64" rx="9" ry="16" fill="url(#bellyGradient)">
                        <animate attributeName="ry" values="16;13;16" dur="0.2s" repeatCount="indefinite" begin="0.1s"/>
                    </ellipse>
                    <ellipse cx="90" cy="62" rx="5" ry="10" fill="#FFFFFF" opacity="0.6">
                        <animate attributeName="ry" values="10;8;10" dur="0.2s" repeatCount="indefinite" begin="0.1s"/>
                    </ellipse>
                    <ellipse cx="88" cy="78" rx="9" ry="5" fill="url(#bellyGradient)"/>
                    <path d="M 81 78 Q 88 82 95 78" stroke="#E8D0C0" stroke-width="1" fill="none" opacity="0.5"/>
                </g>

                <!-- Neck fluff -->
                <ellipse cx="95" cy="42" rx="15" ry="14" fill="url(#bellyGradient)"/>
                <ellipse cx="97" cy="40" rx="10" ry="9" fill="#FFFFFF" opacity="0.7"/>

                <!-- Visual pass - Head with subtle outline -->
                <ellipse cx="105" cy="30" rx="21" ry="19" fill="url(#furGradient)" stroke="#A06018" stroke-width="0.8"/>
                <ellipse cx="107" cy="28" rx="15" ry="13" fill="url(#furHighlight)"/>
                <ellipse cx="104" cy="25" rx="8" ry="6" fill="#FFC870" opacity="0.5"/>

                <!-- Visual pass - Left ear with subtle outline -->
                <g class="tater-ear-left">
                    <ellipse cx="92" cy="14" rx="8" ry="13" fill="url(#furGradient)" transform="rotate(-15 92 14)" stroke="#A06018" stroke-width="0.6"/>
                    <ellipse cx="93" cy="16" rx="5" ry="9" fill="#FFCB8E" transform="rotate(-15 93 16)"/>
                    <ellipse cx="93" cy="18" rx="3" ry="5" fill="#FFD8A8" transform="rotate(-15 93 18)" opacity="0.7"/>
                </g>

                <!-- Visual pass - Right ear with subtle outline -->
                <g class="tater-ear-right">
                    <ellipse cx="115" cy="12" rx="8" ry="13" fill="url(#furGradient)" transform="rotate(15 115 12)" stroke="#A06018" stroke-width="0.6"/>
                    <ellipse cx="114" cy="14" rx="5" ry="9" fill="#FFCB8E" transform="rotate(15 114 14)"/>
                    <ellipse cx="114" cy="16" rx="3" ry="5" fill="#FFD8A8" transform="rotate(15 114 16)" opacity="0.7"/>
                </g>

                <!-- Face marking (white blaze) -->
                <ellipse cx="116" cy="34" rx="12" ry="13" fill="url(#bellyGradient)"/>
                <ellipse cx="117" cy="32" rx="8" ry="9" fill="#FFFFFF" opacity="0.8"/>

                <!-- Snout with better definition -->
                <ellipse cx="122" cy="36" rx="10" ry="9" fill="url(#bellyGradient)"/>
                <ellipse cx="124" cy="35" rx="7" ry="6" fill="#FFFFFF"/>
                <ellipse cx="125" cy="34" rx="4" ry="3" fill="#FFFFFF" opacity="0.8"/>

                <!-- Eyes with more expression -->
                <ellipse cx="102" cy="27" rx="6" ry="7" fill="#FFFFFF"/>
                <ellipse cx="115" cy="27" rx="6" ry="7" fill="#FFFFFF"/>
                <!-- Eye outline for definition -->
                <ellipse cx="102" cy="27" rx="6" ry="7" fill="none" stroke="#C08040" stroke-width="0.5" opacity="0.5"/>
                <ellipse cx="115" cy="27" rx="6" ry="7" fill="none" stroke="#C08040" stroke-width="0.5" opacity="0.5"/>
                <!-- Pupils with shine -->
                <circle cx="104" cy="28" r="4" fill="#2A1810"/>
                <circle cx="117" cy="28" r="4" fill="#2A1810"/>
                <circle cx="105" cy="27" r="1.5" fill="#4A3020"/>
                <circle cx="118" cy="27" r="1.5" fill="#4A3020"/>
                <!-- Eye highlights -->
                <circle cx="102" cy="25" r="2" fill="#FFFFFF"/>
                <circle cx="115" cy="25" r="2" fill="#FFFFFF"/>
                <circle cx="106" cy="29" r="0.8" fill="#FFFFFF" opacity="0.6"/>
                <circle cx="119" cy="29" r="0.8" fill="#FFFFFF" opacity="0.6"/>
                <!-- Eyelids for blink animation -->
                <ellipse class="tater-eyelid-left" cx="102" cy="27" rx="6" ry="7" fill="#E8943C" transform-origin="102px 27px"/>
                <ellipse class="tater-eyelid-right" cx="115" cy="27" rx="6" ry="7" fill="#E8943C" transform-origin="115px 27px"/>

                <!-- Eyebrows with better expression (happy/alert) -->
                <path d="M 97 21 Q 102 19 107 21" stroke="#C07030" stroke-width="2" fill="none" stroke-linecap="round"/>
                <path d="M 110 21 Q 115 19 120 21" stroke="#C07030" stroke-width="2" fill="none" stroke-linecap="round"/>

                <!-- Nose with glossy highlight -->
                <ellipse cx="130" cy="36" rx="4.5" ry="4" fill="url(#noseGradient)"/>
                <ellipse cx="129" cy="34" rx="2" ry="1.2" fill="#5A4A40" opacity="0.6"/>
                <ellipse cx="131" cy="35" rx="1" ry="0.6" fill="#6A5A50" opacity="0.4"/>

                <!-- Mouth with smile -->
                <path d="M 128 40 Q 124 45 118 43 Q 114 41 112 42" stroke="#2A1810" stroke-width="1.8" fill="none" stroke-linecap="round"/>

                <!-- Tongue (animated group) -->
                <g class="tater-tongue">
                    <ellipse cx="120" cy="49" rx="5" ry="8" fill="#FF7080"/>
                    <ellipse cx="120" cy="47" rx="3.5" ry="5" fill="#FF9098"/>
                    <ellipse cx="120" cy="45" rx="2" ry="3" fill="#FFA8B0" opacity="0.8"/>
                    <line x1="120" y1="44" x2="120" y2="54" stroke="#E06070" stroke-width="1.2" stroke-linecap="round"/>
                </g>

                <!-- Cheek blush -->
                <ellipse cx="126" cy="42" rx="3.5" ry="2" fill="#FFB0B0" opacity="0.5"/>
                <ellipse cx="97" cy="32" rx="3" ry="2" fill="#FFB0B0" opacity="0.4"/>

                <!-- Whisker dots -->
                <circle cx="127" cy="39" r="0.8" fill="#C08050" opacity="0.6"/>
                <circle cx="129" cy="41" r="0.8" fill="#C08050" opacity="0.6"/>
                <circle cx="126" cy="43" r="0.8" fill="#C08050" opacity="0.6"/>
            </svg>
            <div class="shadow" id="shadow"></div>
        </div>
    </div>

    <!-- Mobile UI - restructured header with mobile menu -->
    <div class="ui-top">
        <div class="lives-container" id="livesContainer"></div>
        <div class="controls-wrapper">
            <div class="controls">
                <button class="btn" id="muteBtn"><span class="btn-icon">ðŸ”Š</span><span class="btn-label">ðŸ”Š</span></button>
                <button class="btn" id="pauseBtn"><span class="btn-icon">â¸</span><span class="btn-label">Pause</span></button>
                <!-- Mobile UI - desktop-only reset button (inside controls row) -->
                <button class="btn" id="resetBtn"><span class="btn-label">Reset</span></button>
                <!-- Mobile UI - more menu button (mobile only) -->
                <button class="btn mobile-more-btn" id="moreBtn"><span class="btn-icon">â‹¯</span></button>
            </div>
            <!-- Mobile UI - dropdown menu for secondary controls -->
            <div class="mobile-menu" id="mobileMenu">
                <button class="btn" id="resetBtnMobile"><span class="btn-icon">â†»</span><span class="btn-label">Reset</span></button>
                <!-- Accessibility - Settings button in mobile menu -->
                <button class="btn settings-btn" id="settingsBtnMobile"><span class="btn-icon">âš™</span><span class="btn-label">Settings</span></button>
            </div>
        </div>
    </div>

    <div class="game-title">Tater's Adventure Through London</div>
    <div class="score-display">Score: <span id="score">0</span></div>
    <!-- Journey framing - Location display -->
    <div class="location-display" id="locationDisplay">
        <span class="location-name" id="locationName">Lost in Hyde Park</span>
        <span class="location-progress" id="locationProgress">Keeping close.</span>
    </div>
    <!-- Journey framing - Milestone banner (non-blocking) -->
    <!-- Journey framing v2 - Calm milestone banner -->
    <div class="milestone-banner" id="milestoneBanner">
        <div class="milestone-label">A little closer.</div>
        <div class="milestone-name" id="milestoneName">Paddington</div>
    </div>
    <div class="jump-indicator" id="jumpIndicator"></div>
    <!-- Onboarding - hint bar: empty by default, content set dynamically -->
    <div class="hint hidden" id="hintBar"></div>
    <!-- Visual hierarchy & pacing - Part B: Pre-run start prompt -->
    <div class="start-prompt" id="startPrompt">Hold to start</div>

    <div class="damage-flash" id="damageFlash"></div>
    <div class="heal-flash" id="healFlash"></div>
    <!-- Game-over polish - Part B: Vignette overlay for cinematic effect -->
    <div class="vignette-overlay" id="vignetteOverlay"></div>

    <div class="overlay" id="pauseOverlay">
        <div class="overlay-content">
            <div class="overlay-title">Paused</div>
            <button class="overlay-btn" id="resumeBtn">Resume</button>
        </div>
    </div>

    <!-- Game-over polish - Part D: Enhanced game over overlay -->
    <!-- Journey framing - Updated with journey-focused messaging -->
    <!-- CHANGE (story): home clarity â€” title updates when player reached final stage -->
    <div class="overlay" id="gameOverOverlay">
        <div class="overlay-content">
            <div class="overlay-title" id="gameOverTitle">Oh no!</div>
            <div class="game-over-message" id="gameOverMessage">Tater got too scared!</div>
            <!-- Journey framing - Journey result display -->
            <div class="journey-result">
                <div class="journey-label">Tater made it to:</div>
                <div class="journey-location" id="journeyLocation">Hyde Park</div>
                <div class="journey-best" id="journeyBest">Best: Hyde Park</div>
            </div>
            <div class="final-score-display" id="finalScore">0</div>
            <div class="journey-encouragement" id="journeyEncouragement">He's still trying to get homeâ€”let's go again!</div>
            <button class="overlay-btn" id="restartBtn">Try Again</button>
        </div>
        <!-- Game-over polish - Part E: Tap hint -->
        <div class="tap-hint">Tap anywhere to restart</div>
    </div>

    <!-- Step 4 tutorial - first-run tutorial overlay -->
    <div class="overlay" id="tutorialOverlay">
        <div class="overlay-content">
            <div class="overlay-title">How to Play</div>
            <div class="tutorial-tips">
                <div class="tutorial-tip">
                    <span class="tutorial-tip-icon">ðŸ‘†</span>
                    <span>Tap to jump, hold longer for higher jumps</span>
                </div>
                <div class="tutorial-tip">
                    <span class="tutorial-tip-icon">ðŸ¦´</span>
                    <span>Collect bones to restore health</span>
                </div>
                <div class="tutorial-tip">
                    <span class="tutorial-tip-icon">ðŸ˜±</span>
                    <span>Avoid scary things - Tater is easily frightened!</span>
                </div>
            </div>
            <button class="overlay-btn" id="tutorialBtn">Got it!</button>
        </div>
    </div>

    <!-- Share polish - About modal -->
    <div class="overlay" id="aboutOverlay">
        <div class="overlay-content about-content">
            <div class="overlay-title">About</div>
            <div class="about-description">
                Help Tater the corgi run through London, jumping over scary things and collecting bones!
            </div>
            <div class="about-credits">
                <div><strong>Made by Patric</strong></div>
                <div class="about-dedication">for Tater ðŸ•</div>
            </div>
            <button class="overlay-btn" id="aboutCloseBtn">Close</button>
        </div>
    </div>

    <!-- Accessibility - Settings modal -->
    <div class="overlay" id="settingsOverlay">
        <div class="overlay-content settings-content">
            <div class="overlay-title">Settings</div>
            <div class="settings-section">
                <div class="settings-toggle">
                    <div>
                        <div class="settings-toggle-label">Reduce Motion</div>
                        <div class="settings-toggle-desc">Slow/disable non-essential animations</div>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="reduceMotionToggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="settings-toggle">
                    <div>
                        <div class="settings-toggle-label">High Contrast</div>
                        <div class="settings-toggle-desc">Improve UI readability</div>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="highContrastToggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>
            <div class="settings-keyboard">
                <div class="settings-keyboard-title">Keyboard Controls</div>
                <div class="settings-keyboard-item"><kbd>Space</kbd> / <kbd>Enter</kbd> - Hold to jump</div>
                <div class="settings-keyboard-item"><kbd>P</kbd> - Pause</div>
                <div class="settings-keyboard-item"><kbd>R</kbd> - Restart</div>
            </div>
            <button class="overlay-btn secondary" id="helpBtn">How to Play</button>
            <button class="overlay-btn" id="settingsCloseBtn">Close</button>
        </div>
    </div>

    <!-- Share polish - About button -->
    <button class="about-btn" id="aboutBtn" aria-label="About">i</button>

    <!-- Share polish - Version string -->
    <div class="version-string">v0.1</div>

    <script>
        // Debug - lightweight error logging
        window.addEventListener('error', e => {
            console.error('[ERROR]', e.message, 'line:', e.lineno);
        });

        // Debug - set to true to log when pre-run transitions to running
        const DEBUG_START = false;

        // Convenience reference for body
        const body = document.body;

        const tater = document.getElementById('tater');
        const taterContainer = document.getElementById('taterContainer');
        const shadow = document.getElementById('shadow');
        const obstaclesContainer = document.getElementById('obstacles');
        const scoreDisplay = document.getElementById('score');
        const livesContainer = document.getElementById('livesContainer');
        const jumpIndicator = document.getElementById('jumpIndicator');
        const damageFlash = document.getElementById('damageFlash');
        const healFlash = document.getElementById('healFlash');
        const pauseOverlay = document.getElementById('pauseOverlay');
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const finalScoreDisplay = document.getElementById('finalScore');
        const gameContainer = document.querySelector('.game-container');
        const muteBtn = document.getElementById('muteBtn');
        const tutorialOverlay = document.getElementById('tutorialOverlay'); // Step 4 tutorial
        const hintBar = document.getElementById('hintBar'); // UI polish - hint bar reference
        const aboutOverlay = document.getElementById('aboutOverlay'); // Share polish
        const startPrompt = document.getElementById('startPrompt'); // Visual hierarchy & pacing - pre-run prompt
        // Game-over polish - element references
        const vignetteOverlay = document.getElementById('vignetteOverlay');
        const gameOverMessage = document.getElementById('gameOverMessage');
        const gameOverTitle = document.getElementById('gameOverTitle'); // CHANGE (story): home clarity
        // Journey framing - Element references
        const locationDisplay = document.getElementById('locationDisplay');
        const locationName = document.getElementById('locationName');
        const locationProgress = document.getElementById('locationProgress');
        const milestoneBanner = document.getElementById('milestoneBanner');
        const milestoneName = document.getElementById('milestoneName');
        const journeyLocation = document.getElementById('journeyLocation');
        const journeyBest = document.getElementById('journeyBest');
        const journeyEncouragement = document.getElementById('journeyEncouragement');

        // Share polish - About modal functions
        function showAbout() {
            aboutOverlay.classList.add('show');
        }
        function hideAbout() {
            aboutOverlay.classList.remove('show');
        }

        // Accessibility - Settings modal functions
        const settingsOverlay = document.getElementById('settingsOverlay');
        const reduceMotionToggle = document.getElementById('reduceMotionToggle');
        const highContrastToggle = document.getElementById('highContrastToggle');

        function showSettings() {
            settingsOverlay.classList.add('show');
        }
        function hideSettings() {
            settingsOverlay.classList.remove('show');
        }

        // Accessibility - Load settings from localStorage
        function loadAccessibilitySettings() {
            const reduceMotion = localStorage.getItem('taterReduceMotion') === 'true';
            const highContrast = localStorage.getItem('taterHighContrast') === 'true';

            reduceMotionToggle.checked = reduceMotion;
            highContrastToggle.checked = highContrast;

            if (reduceMotion) body.classList.add('reduce-motion');
            if (highContrast) body.classList.add('high-contrast');
        }

        // Accessibility - Helper to refresh sprite animations when Reduce Motion toggles mid-run
        function refreshSpriteAnimations() {
            // Force all sprites with idle classes to recompute their styles
            document.querySelectorAll('.sprite[class*="-idle"]').forEach(sprite => {
                // Get all idle classes on this sprite
                const idleClasses = Array.from(sprite.classList).filter(c => c.endsWith('-idle'));
                if (idleClasses.length > 0) {
                    // Remove and re-add to force CSS recomputation
                    idleClasses.forEach(c => sprite.classList.remove(c));
                    // Use requestAnimationFrame to ensure the removal is processed
                    requestAnimationFrame(() => {
                        idleClasses.forEach(c => sprite.classList.add(c));
                    });
                }
            });
        }

        // Accessibility - Toggle handlers
        reduceMotionToggle.addEventListener('change', () => {
            const enabled = reduceMotionToggle.checked;
            localStorage.setItem('taterReduceMotion', enabled);
            body.classList.toggle('reduce-motion', enabled);
            // Refresh existing sprite animations to apply/remove reduce-motion styles
            refreshSpriteAnimations();
        });

        highContrastToggle.addEventListener('change', () => {
            const enabled = highContrastToggle.checked;
            localStorage.setItem('taterHighContrast', enabled);
            body.classList.toggle('high-contrast', enabled);
        });

        // Accessibility - Load settings on startup
        loadAccessibilitySettings();

        // Step 4 tutorial - check if tutorial has been seen
        let tutorialActive = localStorage.getItem('taterTutorialSeen') !== 'true';

        // Onboarding - toast system state
        let toastTimeout = null;
        let toastShownJump = localStorage.getItem('taterToastJump') === 'true';
        let toastShownBone = localStorage.getItem('taterToastBone') === 'true';

        // Onboarding - check if any overlay is currently visible
        function isAnyOverlayVisible() {
            return isPaused || isGameOver || tutorialActive ||
                   aboutOverlay.classList.contains('show') ||
                   settingsOverlay.classList.contains('show');
        }

        // Onboarding - show a temporary toast message using the hint bar
        function showToast(message, duration = 2000) {
            // Don't show toasts during overlays or pre-run
            if (isAnyOverlayVisible() || preRunState) return;
            // Clear any existing toast
            if (toastTimeout) {
                clearTimeout(toastTimeout);
                toastTimeout = null;
            }
            // Update and show the hint bar as a toast
            hintBar.textContent = message;
            hintBar.classList.remove('hidden', 'toast-out');
            hintBar.classList.add('toast');
            // Schedule fade out
            toastTimeout = setTimeout(() => {
                hintBar.classList.remove('toast');
                hintBar.classList.add('toast-out');
                // Fully hide after animation
                setTimeout(() => {
                    hintBar.classList.add('hidden');
                    hintBar.classList.remove('toast-out');
                }, 400);
                toastTimeout = null;
            }, duration);
        }
        let preRunState = true; // Game starts in pre-run state, waiting for first input

        // Onboarding - show pre-run hint (Mode A: minimal hint during pre-run only)
        function showPreRunHint() {
            if (preRunState && !tutorialActive) {
                hintBar.textContent = 'Tap and hold to start';
                hintBar.classList.remove('hidden', 'toast', 'toast-out');
            }
        }

        // Onboarding - hide hint bar (used when entering gameplay or overlays)
        function hideHintBar() {
            hintBar.classList.add('hidden');
            hintBar.classList.remove('toast', 'toast-out');
            if (toastTimeout) {
                clearTimeout(toastTimeout);
                toastTimeout = null;
            }
        }

        // Onboarding - initialize hint bar state
        // Tutorial takes precedence: no hint during tutorial
        // Pre-run without tutorial: show minimal "Tap and hold to start"
        // In-run: hint stays hidden, toasts appear contextually
        if (tutorialActive) {
            hintBar.classList.add('hidden');
        } else if (preRunState) {
            showPreRunHint();
        } else {
            hintBar.classList.add('hidden');
        }

        // Step 3 sound - WebAudio system
        let audioCtx = null;
        let isMuted = localStorage.getItem('taterMuted') === 'true';
        // Mobile UI - initialize mute button with both icon and label spans
        const initMuteIcon = isMuted ? 'ðŸ”‡' : 'ðŸ”Š';
        muteBtn.innerHTML = `<span class="btn-icon">${initMuteIcon}</span><span class="btn-label">${initMuteIcon}</span>`;

        function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playJump() {
            if (!audioCtx || isMuted) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = 'sine';
            osc.frequency.setValueAtTime(280, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(520, audioCtx.currentTime + 0.08);
            gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.12);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.12);
        }

        function playLand() {
            if (!audioCtx || isMuted) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(180, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.08);
            gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        }

        function playHit() {
            if (!audioCtx || isMuted) return;
            // Noise burst for impact
            const bufferSize = audioCtx.sampleRate * 0.15;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.15));
            }
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 600;
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0.25, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);
            noise.start();
        }

        function playHealOrCollect() {
            if (!audioCtx || isMuted) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = 'sine';
            // Pleasant ascending arpeggio feel
            osc.frequency.setValueAtTime(440, audioCtx.currentTime);
            osc.frequency.setValueAtTime(554, audioCtx.currentTime + 0.06);
            osc.frequency.setValueAtTime(659, audioCtx.currentTime + 0.12);
            gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime + 0.12);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.25);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.25);
        }

        function playGameOver() {
            if (!audioCtx || isMuted) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = 'sawtooth';
            // Descending sad tone
            osc.frequency.setValueAtTime(330, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(110, audioCtx.currentTime + 0.4);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.5);
        }

        function toggleMute() {
            isMuted = !isMuted;
            localStorage.setItem('taterMuted', isMuted);
            // Mobile UI - update both icon and label spans
            const icon = isMuted ? 'ðŸ”‡' : 'ðŸ”Š';
            muteBtn.innerHTML = `<span class="btn-icon">${icon}</span><span class="btn-label">${icon}</span>`;
        }

        // Step 3 juice - hit-stop variable (pause game updates briefly on damage)
        let hitStopUntil = 0;

        // Step 3 juice - floating text helper
        function showFloatText(text, x, y) {
            const el = document.createElement('div');
            el.className = 'float-text';
            el.textContent = text;
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            gameContainer.appendChild(el);
            setTimeout(() => el.remove(), 600);
        }

        // CHANGE (difficulty): MAX_LIVES set to 3 (was 5)
        const MAX_LIVES = 3;

        let score = 0, lives = MAX_LIVES, isPaused = false, isGameOver = false, isJumping = false; // uses MAX_LIVES
        let isHolding = false, jumpPower = 0, velocity = 0, taterY = 0;
        let obstacles = [], powerups = [], lastSpawnTime = 0, lastPowerupTime = 0;
        let gameSpeed = 1, invulnerable = false, baseY = 9;
        // Visual hierarchy & pacing - Part B: Pre-run state

        // ========================================================================
        // JOURNEY v2 (single source of truth) â€” Priority 2
        // Quiet, earned progression. No countdown, no "Next: X in N".
        // 6 stages with atmospheric mood phrases. Milestone banners are brief.
        // ========================================================================

        // Journey framing v2 - London journey milestones (reduced to 6 for emotional weight)
        // Wider gaps between stages make each milestone feel earned
        // CHANGE (copy): Final stage renamed to feel like "almost home" not just arrival
        const JOURNEY_STAGES = [
            { name: 'Lost in Hyde Park', threshold: 0, mood: 'Keeping close.' },
            { name: 'Paddington', threshold: 200, mood: 'Finding the way.' },
            { name: 'Soho', threshold: 450, mood: 'A familiar path.' },
            { name: "St Paul's", threshold: 800, mood: 'Not far now.' },
            { name: 'Tower Bridge', threshold: 1300, mood: 'Nearly safe.' },
            { name: 'Home', threshold: 2000, mood: 'He knows this place' }
        ];

        // CHANGE (copy): Encouragements emphasize progress, not loss
        // Journey framing v2 - Gentle, reflective encouragements (no hype)
        const JOURNEY_ENCOURAGEMENTS = [
            "Each run brings Tater closer to home.",
            "He'll rest, then try again.",
            "A little further each time.",
            "The path home is still there.",
            "Some journeys take patience.",
            "He remembers the way now."
        ];

        // Journey framing - Track current stage index to detect milestone crossings
        let currentJourneyStageIndex = 0;
        let milestoneBannerTimeout = null;
        let milestonesShownThisRun = new Set(); // Gate: only show each milestone once per run

        // Journey framing - Get current journey stage based on score
        function getJourneyStage(currentScore) {
            let stage = JOURNEY_STAGES[0];
            let index = 0;
            for (let i = JOURNEY_STAGES.length - 1; i >= 0; i--) {
                if (currentScore >= JOURNEY_STAGES[i].threshold) {
                    stage = JOURNEY_STAGES[i];
                    index = i;
                    break;
                }
            }
            return { ...stage, index };
        }

        // OLD JOURNEY v1 (disabled) - getNextStage was used for "Next: X in N" countdown
        // Removed: function getNextStage(currentScore) { ... }

        // Journey framing - Get location name from a score value
        function getLocationFromScore(scoreValue) {
            return getJourneyStage(scoreValue).name;
        }

        // Journey framing v2 - Show milestone banner (non-blocking, brief, calm)
        function showMilestoneBanner(stageName) {
            // Clear any existing banner timeout
            if (milestoneBannerTimeout) {
                clearTimeout(milestoneBannerTimeout);
            }

            milestoneName.textContent = stageName;
            milestoneBanner.classList.add('show');

            // Priority 3: Emotional feedback - Tater settles briefly at milestone
            const reduceMotion = body.classList.contains('reduce-motion');
            const settleDuration = reduceMotion ? 500 : 800;
            applyTaterMood('settled', settleDuration);

            // Journey framing v2 - Reduced display time for subtlety (was 2000ms)
            milestoneBannerTimeout = setTimeout(() => {
                milestoneBanner.classList.remove('show');
                milestoneBannerTimeout = null;
            }, reduceMotion ? 1000 : 1400);
        }

        // Journey framing v2 - Update location display and check for milestones
        // Removed countdown "Next: X in N", replaced with quiet atmospheric phrases
        function updateJourneyDisplay(currentScore) {
            const stage = getJourneyStage(currentScore);

            // Update location name
            locationName.textContent = stage.name;

            // Journey framing v2 - Show quiet mood phrase instead of countdown
            // Each stage has its own atmospheric hint; no numbers, no urgency
            locationProgress.textContent = stage.mood || '';

            // Check for milestone crossing (only during active gameplay)
            if (stage.index > currentJourneyStageIndex && !isGameOver && !isPaused && !preRunState) {
                currentJourneyStageIndex = stage.index;
                // Gate: only show milestone banner once per run
                if (!milestonesShownThisRun.has(stage.index)) {
                    milestonesShownThisRun.add(stage.index);
                    showMilestoneBanner(stage.name);
                }
            }
        }

        // Journey framing - Reset journey state (called in resetGame)
        function resetJourneyState() {
            currentJourneyStageIndex = 0;
            milestonesShownThisRun.clear();
            if (milestoneBannerTimeout) {
                clearTimeout(milestoneBannerTimeout);
                milestoneBannerTimeout = null;
            }
            milestoneBanner.classList.remove('show');
            updateJourneyDisplay(0);
        }

        // ========================================================================
        // EMOTION v1 (single source of truth) â€” Priority 3
        // Fatigue ramp: WEARY (800) â†’ TIRED (1300). CSS-only, no physics impact.
        // Defeated + hopeful stacking handled via .tater.defeated.hopeful CSS.
        // Reset via resetTaterEmotionalState() clears all mood classes + timeouts.
        // ========================================================================

        // Tracks temporary emotional states applied to Tater
        let taterMoodTimeout = null;
        let taterHopefulTimeout = null;
        const WEARY_SCORE_THRESHOLD = 800;  // Score at which Tater shows subtle fatigue
        const TIRED_SCORE_THRESHOLD = 1300; // Score at which Tater shows tired-but-determined state
        // CHANGE (emotion): Single source of truth for all Tater mood classes
        // Used in resetTaterEmotionalState to ensure no mood leaks between runs
        const TATER_MOOD_CLASSES = ['settled', 'weary', 'tired', 'hopeful', 'defeated', 'hurt', 'healed'];

        // Priority 3: Emotional feedback - Apply temporary mood class to Tater
        // Ensures classes don't stack weirdly, clears prior timeouts
        function applyTaterMood(className, durationMs) {
            // Clear any existing mood timeout to prevent stacking
            if (taterMoodTimeout) {
                clearTimeout(taterMoodTimeout);
                taterMoodTimeout = null;
            }

            // Remove other temporary mood classes (but not persistent states like tired/defeated)
            tater.classList.remove('settled');

            // Apply the new mood
            tater.classList.add(className);

            // Schedule removal
            taterMoodTimeout = setTimeout(() => {
                tater.classList.remove(className);
                taterMoodTimeout = null;
            }, durationMs);
        }

        // Priority 3: Emotional feedback - Update fatigue state based on score
        // Called from score update locations; implements weary â†’ tired ramp
        function updateTaterTiredState(currentScore) {
            if (isGameOver) return;

            if (currentScore >= TIRED_SCORE_THRESHOLD) {
                // Late run: upgrade to tired, remove weary
                if (!tater.classList.contains('tired')) {
                    tater.classList.remove('weary');
                    tater.classList.add('tired');
                }
            } else if (currentScore >= WEARY_SCORE_THRESHOLD) {
                // Mid-late run: show weary (if not already tired)
                if (!tater.classList.contains('tired') && !tater.classList.contains('weary')) {
                    tater.classList.add('weary');
                }
            }
        }

        // Priority 3: Emotional feedback - Reset emotional states (called in resetGame)
        // CHANGE (emotion): clear all Tater mood classes on restart
        function resetTaterEmotionalState() {
            // Clear timeouts
            if (taterMoodTimeout) {
                clearTimeout(taterMoodTimeout);
                taterMoodTimeout = null;
            }
            if (taterHopefulTimeout) {
                clearTimeout(taterHopefulTimeout);
                taterHopefulTimeout = null;
            }
            // Remove all emotional/mood classes using single source of truth
            tater.classList.remove(...TATER_MOOD_CLASSES);
        }

        // Journey framing - Get random encouragement message
        function getJourneyEncouragement() {
            return JOURNEY_ENCOURAGEMENTS[Math.floor(Math.random() * JOURNEY_ENCOURAGEMENTS.length)];
        }

        // Journey framing v2 - Update game over display with gentle journey info
        // No emoji, no hype; reflective and warm tone
        function updateGameOverJourney(finalScore) {
            const currentLocation = getLocationFromScore(finalScore);
            const bestScore = parseInt(localStorage.getItem('taterBestScore') || '0', 10);
            const bestLocation = getLocationFromScore(bestScore);
            const isNewBest = finalScore > bestScore;

            journeyLocation.textContent = currentLocation;

            // Journey framing v2 - Gentle "furthest" messaging, no emoji
            if (isNewBest) {
                journeyBest.textContent = `A new furthest point: ${currentLocation}`;
                journeyBest.classList.add('new-best');
            } else {
                journeyBest.textContent = `Furthest so far: ${bestLocation}`;
                journeyBest.classList.remove('new-best');
            }

            journeyEncouragement.textContent = getJourneyEncouragement();
        }

        // Step 2.5 spawn pacing - spawn tracking variables
        let lastAirSpawnTime = 0;      // Tracks when last air hazard was spawned
        let lastTallSpawnTime = 0;     // Tracks when last tall/large obstacle was spawned
        let consecutiveSpawns = 0;     // Counts spawns since last breather
        let lastSpawnedType = null;    // Tracks last spawned obstacle type
        let lastSpawnedCategory = null; // Step 2.5 spawn pacing - track ground/air category
        let patternQueue = [];          // Step 2.5 spawn pacing - queued pattern obstacles
        let lastTallSpawnFrame = 0;     // Anti-cluster: tracks frame when tall hazard spawned

        // Gameplay polish - DEBUG flag for spawn decision logging
        const DEBUG = false;

        // Startup sanity check - confirms game initialized correctly
        if (DEBUG) {
            console.log('[INIT] Game initialized: preRunState=' + preRunState + ', tutorialActive=' + tutorialActive);
        }

        // Step 2.5 spawn pacing - categorization constants
        // ROSTER UPDATE: removed firework/hairdryer, added umbrella/frisbee, moved pigeon to air
        const AIR_HAZARDS = ['thunder', 'balloon', 'umbrella', 'frisbee', 'pigeon']; // groundY >= 12
        const GROUND_HAZARDS = ['mailman', 'vacuum', 'cat', 'cone', 'vet', 'squirrel', 'skateboard'];
        const TALL_HAZARDS = ['mailman', 'vet', 'cone', 'vacuum']; // height 50+ or width 60+
        const SMALL_HAZARDS = ['cat', 'squirrel', 'skateboard'];

        // Step 2.5 spawn pacing - PART 1: Anti-cluster spacing constants
        const BASE_REACTION_PX = 120;    // Minimum base spacing in pixels
        const SPEED_FACTOR_PX = 40;      // Additional spacing per gameSpeed unit
        const WIDTH_FACTOR = 0.8;        // Multiplier for obstacle width contribution
        const AIR_EXTRA_SPACING = 60;    // Extra spacing if air hazard involved
        const TALL_EXTRA_SPACING = 50;   // Extra spacing if tall hazard involved
        const SPEED_EXPONENT = 1.4;      // Nonlinear scaling exponent for gameSpeed
        const HARD_MIN_DISTANCE = 200;   // Absolute minimum px from spawnX regardless of timing
        const TALL_RECOVERY_FRAMES = 90; // Frames of recovery window after tall hazard (~1.5s)
        const RECOVERY_EXTRA_SPACING = 80; // Gameplay polish - extra spacing during recovery window

        // Step 2.5 spawn pacing - PART 2: Pacing timing constants
        const AIR_COOLDOWN = 3000;       // ms before another air hazard can spawn
        const TALL_COOLDOWN = 2500;      // ms before another tall hazard can spawn
        const BREATHER_INTERVAL = 4;     // Guarantee breather after this many consecutive spawns
        const BREATHER_DELAY = 1000;     // Extra delay ms for breather
        const PATTERN_SCORE_INTERVAL = 150; // Trigger pattern every N score points

        // ============================================================
        // DIFFICULTY CURVE SYSTEM - 3-Act emotional arc
        // Early: calm, learnable, forgiving
        // Mid: tense, focused, "barely made it"
        // Late: desperate but still fair
        // ============================================================

        // Debug flag for difficulty tuning
        const DEBUG_DIFFICULTY = false;

        // Speed curve constants - smooth 3-act progression
        const SPEED_START = 1.0;         // Starting game speed
        const SPEED_MID = 1.6;           // Speed at mid-game tension point (tuned up from 1.5)
        const SPEED_MAX = 2.3;           // Maximum speed (asymptotic limit)
        const RAMP_SCORE_START = 0;      // Score where ramp begins
        const RAMP_SCORE_MID = 300;      // Score at mid-game (tension builds) - tuned down from 400
        const RAMP_SCORE_END = 1200;     // Score where speed approaches max (asymptotic)

        // Difficulty tier thresholds - TUNED for earlier MID tension
        const TIER_EARLY_END = 120;      // End of early/calm phase (was 150, now earlier MID entry)
        const TIER_MID_END = 750;        // End of mid/tension phase (was 600, extended MID duration)

        // Tier-based spawn timing (ms) - TUNED for tenser MID
        const SPAWN_DELAY_EARLY = { base: 2800, min: 2000 };  // Unchanged - keep EARLY calm
        const SPAWN_DELAY_MID = { base: 1900, min: 1250 };    // Tighter (was 2200/1500)
        const SPAWN_DELAY_LATE = { base: 1500, min: 1000 };   // Slightly tighter (was 1600/1100)

        // Tier-based spacing multipliers (applied to base spacing) - TUNED for tenser MID
        const SPACING_MULT_EARLY = 1.3;  // 30% more spacing in early game - unchanged
        const SPACING_MULT_MID = 0.85;   // 15% tighter spacing in mid game (was 1.0)
        const SPACING_MULT_LATE = 0.85;  // Same as MID floor (was 0.9)

        // Tier-based minimum survivable gap (absolute floor) - PRESERVED for fairness
        const MIN_SURVIVABLE_GAP_EARLY = 280;  // Unchanged - safety first
        const MIN_SURVIVABLE_GAP_MID = 230;    // Slightly tighter (was 240) but still fair
        const MIN_SURVIVABLE_GAP_LATE = 200;   // Unchanged - absolute floor

        // Tier-based hazard probabilities - TUNED for more "hard moments" in MID
        const AIR_HAZARD_CHANCE_EARLY = 0.15;   // 15% chance - unchanged
        const AIR_HAZARD_CHANCE_MID = 0.38;     // 38% chance (was 0.28) - more air hazards
        const AIR_HAZARD_CHANCE_LATE = 0.42;    // 42% chance (was 0.38)
        const TALL_HAZARD_CHANCE_EARLY = 0.20;  // 20% chance - unchanged
        const TALL_HAZARD_CHANCE_MID = 0.42;    // 42% chance (was 0.35) - more tall hazards
        const TALL_HAZARD_CHANCE_LATE = 0.48;   // 48% chance (was 0.45)

        // Post-hard-hazard breather settings
        const POST_HARD_BREATHER_DELAY = 400;   // Extra ms delay after tall/air hazard
        const POST_HARD_SMALL_ONLY_CHANCE = 0.6; // 60% chance next spawn is small-only after hard hazard
        let lastHardHazardTime = 0;             // Track when last hard hazard spawned

        // Consecutive spawn limiting by tier
        const MAX_CONSECUTIVE_EARLY = 2;
        const MAX_CONSECUTIVE_MID = 3;
        const MAX_CONSECUTIVE_LATE = 4;

        // Get current difficulty tier based on score
        function getDifficultyTier(currentScore) {
            if (currentScore < TIER_EARLY_END) return 'EARLY';
            if (currentScore < TIER_MID_END) return 'MID';
            return 'LATE';
        }

        // Calculate smooth 3-act speed curve using logistic-style sigmoid
        // This creates: slow ramp early â†’ steep ramp mid â†’ asymptotic late
        function calculateGameSpeed(currentScore) {
            if (currentScore <= RAMP_SCORE_START) return SPEED_START;

            // Normalized progress through the difficulty curve (0 to ~1+)
            const progress = (currentScore - RAMP_SCORE_START) / (RAMP_SCORE_END - RAMP_SCORE_START);

            // Sigmoid curve: slow start, steep middle, asymptotic end
            // Using modified logistic: speed = start + (max-start) * sigmoid(progress)
            // TUNED: Sigmoid centered earlier for faster MID-game tension buildup
            const k = 7; // Steepness of the curve (was 6, now steeper for sharper MID ramp)
            const midpoint = 0.22; // Where the curve is steepest (was 0.35, now earlier for tension by ~250)
            const sigmoid = 1 / (1 + Math.exp(-k * (progress - midpoint)));

            // Map sigmoid (0-1) to speed range
            const speed = SPEED_START + (SPEED_MAX - SPEED_START) * sigmoid;

            return Math.min(SPEED_MAX, Math.max(SPEED_START, speed));
        }

        // Get tier-specific spawn delay parameters
        function getSpawnDelayParams(tier) {
            switch (tier) {
                case 'EARLY': return SPAWN_DELAY_EARLY;
                case 'MID': return SPAWN_DELAY_MID;
                case 'LATE': return SPAWN_DELAY_LATE;
                default: return SPAWN_DELAY_MID;
            }
        }

        // Get tier-specific spacing multiplier
        function getSpacingMultiplier(tier) {
            switch (tier) {
                case 'EARLY': return SPACING_MULT_EARLY;
                case 'MID': return SPACING_MULT_MID;
                case 'LATE': return SPACING_MULT_LATE;
                default: return SPACING_MULT_MID;
            }
        }

        // Get tier-specific minimum survivable gap
        function getMinSurvivableGap(tier) {
            switch (tier) {
                case 'EARLY': return MIN_SURVIVABLE_GAP_EARLY;
                case 'MID': return MIN_SURVIVABLE_GAP_MID;
                case 'LATE': return MIN_SURVIVABLE_GAP_LATE;
                default: return MIN_SURVIVABLE_GAP_MID;
            }
        }

        // Get tier-specific max consecutive spawns before forced breather
        function getMaxConsecutive(tier) {
            switch (tier) {
                case 'EARLY': return MAX_CONSECUTIVE_EARLY;
                case 'MID': return MAX_CONSECUTIVE_MID;
                case 'LATE': return MAX_CONSECUTIVE_LATE;
                default: return MAX_CONSECUTIVE_MID;
            }
        }

        // Check if obstacle type is "hard" (tall or air)
        function isHardHazard(obstacleType) {
            if (!obstacleType) return false;
            return TALL_HAZARDS.includes(obstacleType.id) || AIR_HAZARDS.includes(obstacleType.id);
        }

        // Debug logging for difficulty system
        let lastLoggedTier = null;
        function logDifficulty(tier, speed, minSpacing, spawnDelay, extraInfo = '') {
            if (!DEBUG_DIFFICULTY) return;
            // Only log on tier change or periodically
            if (tier !== lastLoggedTier) {
                console.log(`[DIFFICULTY] Tier changed to: ${tier}`);
                lastLoggedTier = tier;
            }
            console.log(`[DIFFICULTY] tier=${tier} speed=${speed.toFixed(2)} minSpacing=${minSpacing.toFixed(0)} spawnDelay=${spawnDelay.toFixed(0)}${extraInfo}`);
        }

        // Jump feel improvement - timing variables
        let lastGroundedTime = 0;    // Tracks when player was last on ground
        let jumpBufferTime = 0;      // Tracks when player last attempted to jump
        const COYOTE_TIME = 100;     // ms - allows jump shortly after leaving ground
        const JUMP_BUFFER_TIME = 100; // ms - queues jump if released just before landing
        const MIN_JUMP_VELOCITY = 6; // Ensures short taps still produce a visible hop
        const GRAVITY_UP = 0.50;     // Gentler gravity while rising (ease-out feel)
        const GRAVITY_DOWN = 0.85;   // Stronger gravity while falling (snappier descent)

        // Visual pass - obstacle SVGs with consistent outlines for silhouette readability
        const scaryThings = [
            // Visual pass: Mailman with stronger outline, simplified details
            { id: 'mailman', width: 45, height: 75, groundY: 9,
                svg: `<svg viewBox="0 0 45 75"><g stroke="#2A1A10" stroke-width="1.5"><rect x="10" y="52" width="9" height="23" rx="3" fill="#1A1A1A"/><rect x="26" y="52" width="9" height="23" rx="3" fill="#1A1A1A"/><ellipse cx="22" cy="38" rx="13" ry="18" fill="#CC2020"/><rect x="9" y="28" width="8" height="14" rx="2" fill="#8B4513" stroke-width="1"/><circle cx="22" cy="14" r="10" fill="#FFDAB9"/><rect x="10" y="3" width="24" height="12" rx="3" fill="#1A3A6E"/><ellipse cx="22" cy="6" rx="10" ry="3" fill="#1A3A6E" stroke="none"/></g><rect x="18" y="0" width="8" height="4" fill="#CC2020"/><ellipse cx="17" cy="13" rx="2.5" ry="3" fill="#2A1810"/><ellipse cx="27" cy="13" rx="2.5" ry="3" fill="#2A1810"/><path d="M 19 18 Q 22 20 25 18" stroke="#5A3A2A" stroke-width="2" fill="none"/><rect x="30" y="35" width="12" height="9" fill="#FFF8DC" stroke="#8B6914" stroke-width="1.5"/></svg>` },
            // Visual pass: Vacuum with stronger outline
            { id: 'vacuum', width: 60, height: 50, groundY: 9,
                svg: `<svg viewBox="0 0 60 50"><g stroke="#1A1A1A" stroke-width="1.5"><ellipse cx="30" cy="40" rx="25" ry="10" fill="#3A3A3A"/><rect x="20" y="8" width="20" height="32" rx="7" fill="#E05040"/></g><ellipse cx="30" cy="38" rx="21" ry="8" fill="#4D4D4D"/><rect x="24" y="13" width="12" height="8" rx="2" fill="#222" stroke="#1A1A1A" stroke-width="1"/><circle cx="30" cy="17" r="3" fill="#FF6B6B"><animate attributeName="opacity" values="1;0.3;1" dur="0.4s" repeatCount="indefinite"/></circle><path d="M 12 35 Q 0 27 5 15" stroke="#3A3A3A" stroke-width="6" fill="none" stroke-linecap="round"/><ellipse cx="5" cy="13" rx="5" ry="3" fill="#444" stroke="#222" stroke-width="1"/></svg>` },
            // Visual pass: Pigeon with stronger outline
            { id: 'pigeon', width: 40, height: 35, groundY: 25,
                svg: `<svg viewBox="0 0 40 35"><g stroke="#3A3A3A" stroke-width="1.2"><ellipse cx="22" cy="24" rx="14" ry="9" fill="#707070"/><circle cx="10" cy="17" r="9" fill="#808080"/></g><ellipse cx="4" cy="20" rx="5" ry="3" fill="#909090"/><circle cx="7" cy="15" r="3" fill="#FF8C00" stroke="#CC6600" stroke-width="1"/><circle cx="9" cy="14" r="1.5" fill="#111"/><path d="M 34 26 L 40 22 L 38 26 L 40 30 L 34 26" fill="#606060" stroke="#3A3A3A" stroke-width="1"/><path d="M 30 20 Q 38 15 36 22" fill="#707070"/></svg>` },
            // Visual pass: Thunder with stronger cloud outline
            { id: 'thunder', width: 70, height: 50, groundY: 35,
                svg: `<svg viewBox="0 0 70 50"><g stroke="#3A4558" stroke-width="1.5"><ellipse cx="35" cy="20" rx="32" ry="18" fill="#5A6578"/><ellipse cx="18" cy="23" rx="16" ry="13" fill="#4A5568"/><ellipse cx="52" cy="23" rx="14" ry="11" fill="#4A5568"/></g><ellipse cx="35" cy="17" rx="22" ry="10" fill="#6A7588"/><path d="M 32 32 L 40 32 L 35 42 L 46 42 L 28 58 L 36 44 L 24 44 Z" fill="#FFD700" stroke="#CC9900" stroke-width="1"><animate attributeName="opacity" values="1;0.2;1;0.4;1" dur="0.3s" repeatCount="indefinite"/></path></svg>` },
            // Visual pass: Cat with stronger outline
            { id: 'cat', width: 48, height: 45, groundY: 9,
                svg: `<svg viewBox="0 0 48 45"><g stroke="#2A2A2A" stroke-width="1.2"><ellipse cx="30" cy="32" rx="16" ry="10" fill="#4A4A4A"/><path d="M 44 26 Q 54 20 48 32" fill="#4A4A4A"/><circle cx="15" cy="20" r="12" fill="#4A4A4A"/></g><ellipse cx="17" cy="34" rx="7" ry="9" fill="#4A4A4A"/><polygon points="5,18 2,4 12,12" fill="#4A4A4A" stroke="#2A2A2A" stroke-width="1"/><polygon points="26,16 31,3 22,10" fill="#4A4A4A" stroke="#2A2A2A" stroke-width="1"/><polygon points="7,16 4,7 11,11" fill="#FF9090"/><polygon points="25,14 29,6 22,10" fill="#FF9090"/><ellipse cx="10" cy="18" rx="4" ry="5" fill="#90EE90" stroke="#50AA50" stroke-width="0.8"/><ellipse cx="21" cy="18" rx="4" ry="5" fill="#90EE90" stroke="#50AA50" stroke-width="0.8"/><ellipse cx="10" cy="18" rx="1.5" ry="4" fill="#111"/><ellipse cx="21" cy="18" rx="1.5" ry="4" fill="#111"/><ellipse cx="15" cy="25" rx="3" ry="2" fill="#FFB6C1"/></svg>` },
            // Visual pass: Cone with stronger outline
            { id: 'cone', width: 45, height: 50, groundY: 9,
                svg: `<svg viewBox="0 0 45 50"><ellipse cx="22" cy="45" rx="20" ry="5" fill="#D8D8D8" stroke="#A0A0A0" stroke-width="1.5"/><path d="M 2 45 L 15 10 L 30 10 L 43 45 Z" fill="#E8F4F8" stroke="#A0B0B8" stroke-width="2"/><ellipse cx="22" cy="10" rx="8" ry="3" fill="#E8F4F8" stroke="#A0B0B8" stroke-width="1.5"/><circle cx="22" cy="32" r="7" fill="#FFDAB9" stroke="#C0A080" stroke-width="1"/><ellipse cx="20" cy="31" rx="2" ry="2.5" fill="#2A1A10"/><ellipse cx="24" cy="31" rx="2" ry="2.5" fill="#2A1A10"/><ellipse cx="22" cy="36" rx="2.5" ry="1.5" fill="#2A1A10"/></svg>` },
            // Visual pass: Vet with stronger outline
            { id: 'vet', width: 40, height: 70, groundY: 9,
                svg: `<svg viewBox="0 0 40 70"><g stroke="#1A1A1A" stroke-width="1.5"><rect x="8" y="50" width="8" height="20" rx="3" fill="#1A1A1A"/><rect x="24" y="50" width="8" height="20" rx="3" fill="#1A1A1A"/><ellipse cx="20" cy="35" rx="12" ry="18" fill="#FFFFFF"/><circle cx="20" cy="12" r="9" fill="#FFDAB9"/></g><rect x="14" y="25" width="12" height="15" fill="#FFFFFF"/><ellipse cx="16" cy="11" rx="2.5" ry="2.5" fill="#2A1A10"/><ellipse cx="24" cy="11" rx="2.5" ry="2.5" fill="#2A1A10"/><path d="M 18 15 Q 20 17 22 15" stroke="#5A3A2A" stroke-width="1.5" fill="none"/><rect x="30" y="28" width="12" height="4" rx="1" fill="#C0C0C0" stroke="#808080" stroke-width="1"/><rect x="38" y="26" width="4" height="8" rx="1" fill="#A0A0A0"/><rect x="15" y="30" width="5" height="7" fill="#FF4444" stroke="#CC2222" stroke-width="0.8"/><rect x="17.5" y="28" width="1" height="11" fill="#FF4444"/></svg>` },
            // Visual pass: Squirrel with stronger outline
            { id: 'squirrel', width: 40, height: 45, groundY: 9,
                svg: `<svg viewBox="0 0 40 45"><g stroke="#5A4010" stroke-width="1.2"><path d="M 5 15 Q 0 5 8 8 Q 15 5 12 18" fill="#8B6914"/><ellipse cx="20" cy="30" rx="12" ry="10" fill="#A07828"/><circle cx="15" cy="18" r="10" fill="#A07828"/></g><ellipse cx="25" cy="35" rx="5" ry="7" fill="#A07828"/><ellipse cx="15" cy="36" rx="4" ry="6" fill="#A07828"/><ellipse cx="10" cy="10" rx="4" ry="5" fill="#A07828" stroke="#5A4010" stroke-width="0.8"/><ellipse cx="20" cy="10" rx="4" ry="5" fill="#A07828" stroke="#5A4010" stroke-width="0.8"/><ellipse cx="10" cy="10" rx="2" ry="3" fill="#C09038"/><ellipse cx="20" cy="10" rx="2" ry="3" fill="#C09038"/><ellipse cx="10" cy="17" rx="3.5" ry="4" fill="#FFFFFF" stroke="#888" stroke-width="0.5"/><ellipse cx="19" cy="17" rx="3.5" ry="4" fill="#FFFFFF" stroke="#888" stroke-width="0.5"/><circle cx="11" cy="18" r="2.5" fill="#111"/><circle cx="20" cy="18" r="2.5" fill="#111"/><ellipse cx="14" cy="23" rx="2.5" ry="2" fill="#2A1A10"/><ellipse cx="20" cy="28" rx="8" ry="5" fill="#C09038"/></svg>` },
            // Visual pass: Balloon with stronger outline
            { id: 'balloon', width: 38, height: 60, groundY: 12,
                svg: `<svg viewBox="0 0 38 60"><path d="M 19 55 Q 19 48 19 45" stroke="#6B4520" stroke-width="2" fill="none"/><ellipse cx="19" cy="24" rx="17" ry="22" fill="#FF6B6B" stroke="#CC4040" stroke-width="1.5"/><ellipse cx="19" cy="21" rx="13" ry="17" fill="#FF8585"/><ellipse cx="14" cy="17" rx="5" ry="8" fill="rgba(255,255,255,0.4)"/><polygon points="19,46 14,41 24,41" fill="#FF6B6B" stroke="#CC4040" stroke-width="1"/></svg>` },
            // Visual pass: Skateboard with stronger outline
            { id: 'skateboard', width: 65, height: 22, groundY: 9,
                svg: `<svg viewBox="0 0 65 22"><rect x="5" y="5" width="55" height="8" rx="4" fill="#A0522D" stroke="#6A3010" stroke-width="1.5"/><rect x="8" y="6" width="49" height="5" rx="2" fill="#B8652D"/><rect x="12" y="13" width="10" height="3" fill="#222" stroke="#111" stroke-width="0.8"/><rect x="43" y="13" width="10" height="3" fill="#222" stroke="#111" stroke-width="0.8"/><circle cx="15" cy="19" r="4" fill="#1A1A1A" stroke="#000" stroke-width="1"/><circle cx="50" cy="19" r="4" fill="#1A1A1A" stroke="#000" stroke-width="1"/></svg>` },
            // Visual pass: Umbrella with stronger outline
            { id: 'umbrella', width: 55, height: 55, groundY: 25,
                svg: `<svg viewBox="0 0 55 55"><path d="M 27 8 Q 5 12 5 28 Q 5 32 10 32 Q 12 28 15 28 Q 18 28 20 32 Q 22 28 27 28 Q 32 28 34 32 Q 36 28 39 28 Q 42 28 44 32 Q 49 32 49 28 Q 49 12 27 8 Z" fill="#CC2020" stroke="#8A1010" stroke-width="1.5"/><ellipse cx="27" cy="10" rx="8" ry="3" fill="#DD3030"/><line x1="27" y1="8" x2="27" y2="48" stroke="#6B3510" stroke-width="3"/><path d="M 27 48 Q 22 52 20 48" stroke="#6B3510" stroke-width="3" fill="none" stroke-linecap="round"/></svg>` },
            // Visual pass: Frisbee with stronger outline
            { id: 'frisbee', width: 50, height: 24, groundY: 20,
                svg: `<svg viewBox="0 0 50 24"><ellipse cx="25" cy="12" rx="24" ry="11" fill="#3498DB" stroke="#1A6090" stroke-width="1.5"/><ellipse cx="25" cy="10" rx="20" ry="8" fill="#5DADE2"/><ellipse cx="25" cy="9" rx="14" ry="5" fill="#85C1E9"/><ellipse cx="25" cy="14" rx="22" ry="9" fill="none" stroke="#2980B9" stroke-width="2"/><ellipse cx="20" cy="8" rx="5" ry="2.5" fill="rgba(255,255,255,0.35)"/></svg>` }
        ];

        // Visual pass - bone SVGs with consistent outline
        const boneSVG = `<svg viewBox="0 0 45 26"><g stroke="#B8A070" stroke-width="1.2"><ellipse cx="7" cy="6" rx="7" ry="5" fill="#F5DEB3"/><ellipse cx="7" cy="20" rx="7" ry="5" fill="#F5DEB3"/><ellipse cx="38" cy="6" rx="7" ry="5" fill="#F5DEB3"/><ellipse cx="38" cy="20" rx="7" ry="5" fill="#F5DEB3"/><rect x="7" y="6" width="31" height="14" fill="#F5DEB3" stroke="none"/></g><ellipse cx="7" cy="6" rx="4" ry="3" fill="#FFF8DC"/><ellipse cx="38" cy="6" rx="4" ry="3" fill="#FFF8DC"/><ellipse cx="22" cy="13" rx="7" ry="4" fill="#FFE4B5"/></svg>`;
        const lifeBoneSVG = `<svg viewBox="0 0 34 20"><g stroke="#5A4A30" stroke-width="1"><ellipse cx="5" cy="5" rx="5" ry="4" fill="#8B6B50"/><ellipse cx="5" cy="15" rx="5" ry="4" fill="#8B6B50"/><ellipse cx="29" cy="5" rx="5" ry="4" fill="#8B6B50"/><ellipse cx="29" cy="15" rx="5" ry="4" fill="#8B6B50"/><rect x="5" y="5" width="24" height="10" fill="#8B6B50" stroke="none"/></g><ellipse cx="5" cy="5" rx="3" ry="2.5" fill="#A08060"/><ellipse cx="29" cy="5" rx="3" ry="2.5" fill="#A08060"/></svg>`;

        function generateBackground() {
            // Seamless parallax fix: clear all layers first
            const clouds = document.getElementById('clouds');
            const far = document.getElementById('landmarksFar');
            const mid = document.getElementById('landmarksMid');
            const park = document.getElementById('parkElements');
            clouds.innerHTML = '';
            far.innerHTML = '';
            mid.innerHTML = '';
            park.innerHTML = '';

            // Helper: duplicate elements for seamless 200% width tiling
            function duplicateForSeamless(container, baseWidth) {
                const children = Array.from(container.children);
                children.forEach(child => {
                    const clone = child.cloneNode(true);
                    const currentLeft = parseFloat(child.style.left) || 0;
                    clone.style.left = (currentLeft + baseWidth) + 'px';
                    container.appendChild(clone);
                });
            }

            // CLOUDS - generate for first half, then duplicate
            const cloudBaseWidth = window.innerWidth;
            for (let i = 0; i < 8; i++) {
                const c = document.createElement('div');
                c.className = 'cloud';
                const left = (i / 8) * cloudBaseWidth;
                c.style.cssText = `left:${left}px;top:${5+Math.random()*90}px;width:${60+Math.random()*100}px;height:${25+Math.random()*35}px`;
                clouds.appendChild(c);
            }
            duplicateForSeamless(clouds, cloudBaseWidth);

            // FAR LAYER - London skyline with iconic landmarks + terraced roofs with chimneys
            const farSVGs = [
                // Big Ben / Elizabeth Tower silhouette
                `<svg width="45" height="160" viewBox="0 0 45 160"><rect x="12" y="30" width="21" height="130" fill="#8090A0" opacity="0.45"/><rect x="8" y="25" width="29" height="12" fill="#8090A0" opacity="0.45"/><rect x="17" y="10" width="11" height="18" fill="#8090A0" opacity="0.45"/><polygon points="22.5,0 14,10 31,10" fill="#8090A0" opacity="0.45"/><circle cx="22.5" cy="45" r="7" fill="#A0B0C0" opacity="0.35"/><rect x="20" y="60" width="5" height="8" fill="#A0B0C0" opacity="0.3"/><rect x="20" y="80" width="5" height="8" fill="#A0B0C0" opacity="0.3"/><rect x="20" y="100" width="5" height="8" fill="#A0B0C0" opacity="0.3"/></svg>`,
                // Terraced townhouse row with chimneys (London recognizable)
                `<svg width="120" height="100" viewBox="0 0 120 100"><rect x="2" y="30" width="28" height="70" fill="#9898A0" opacity="0.42"/><rect x="32" y="25" width="28" height="75" fill="#A0A098" opacity="0.42"/><rect x="62" y="35" width="28" height="65" fill="#9090A0" opacity="0.42"/><rect x="92" y="28" width="26" height="72" fill="#A8A0A0" opacity="0.42"/><rect x="8" y="20" width="4" height="12" fill="#707078" opacity="0.5"/><rect x="18" y="18" width="4" height="14" fill="#707078" opacity="0.5"/><rect x="40" y="15" width="4" height="12" fill="#707078" opacity="0.5"/><rect x="52" y="17" width="4" height="10" fill="#707078" opacity="0.5"/><rect x="70" y="25" width="4" height="12" fill="#707078" opacity="0.5"/><rect x="82" y="27" width="4" height="10" fill="#707078" opacity="0.5"/><rect x="100" y="18" width="4" height="12" fill="#707078" opacity="0.5"/><rect x="110" y="20" width="4" height="10" fill="#707078" opacity="0.5"/><rect x="8" y="45" width="6" height="10" fill="#B0A8A0" opacity="0.3"/><rect x="18" y="45" width="6" height="10" fill="#B0A8A0" opacity="0.3"/><rect x="40" y="40" width="6" height="10" fill="#B0A8A0" opacity="0.3"/><rect x="50" y="40" width="6" height="10" fill="#B0A8A0" opacity="0.3"/><rect x="70" y="50" width="6" height="10" fill="#B0A8A0" opacity="0.3"/><rect x="80" y="50" width="6" height="10" fill="#B0A8A0" opacity="0.3"/><rect x="100" y="43" width="6" height="10" fill="#B0A8A0" opacity="0.3"/><rect x="110" y="43" width="6" height="10" fill="#B0A8A0" opacity="0.3"/></svg>`,
                // London Eye silhouette
                `<svg width="100" height="130" viewBox="0 0 100 130"><circle cx="50" cy="55" r="48" fill="none" stroke="#9098A8" stroke-width="3" opacity="0.4"/><rect x="46" y="103" width="8" height="27" fill="#808890" opacity="0.4"/><line x1="50" y1="7" x2="50" y2="103" stroke="#9098A8" stroke-width="1.5" opacity="0.3"/><line x1="2" y1="55" x2="98" y2="55" stroke="#9098A8" stroke-width="1.5" opacity="0.3"/><ellipse cx="50" cy="15" rx="4" ry="6" fill="#A0A8B0" opacity="0.35"/><ellipse cx="50" cy="95" rx="4" ry="6" fill="#A0A8B0" opacity="0.35"/><ellipse cx="10" cy="55" rx="4" ry="6" fill="#A0A8B0" opacity="0.35"/><ellipse cx="90" cy="55" rx="4" ry="6" fill="#A0A8B0" opacity="0.35"/></svg>`,
                // More terraced houses with varied roofline
                `<svg width="100" height="95" viewBox="0 0 100 95"><rect x="2" y="32" width="30" height="63" fill="#A8A098" opacity="0.4"/><rect x="34" y="28" width="30" height="67" fill="#9898A0" opacity="0.4"/><rect x="66" y="35" width="32" height="60" fill="#A0A090" opacity="0.4"/><rect x="10" y="22" width="4" height="12" fill="#686870" opacity="0.5"/><rect x="22" y="24" width="4" height="10" fill="#686870" opacity="0.5"/><rect x="44" y="18" width="4" height="12" fill="#686870" opacity="0.5"/><rect x="54" y="20" width="4" height="10" fill="#686870" opacity="0.5"/><rect x="76" y="25" width="4" height="12" fill="#686870" opacity="0.5"/><rect x="88" y="27" width="4" height="10" fill="#686870" opacity="0.5"/><rect x="8" y="45" width="7" height="12" fill="#B8B0A8" opacity="0.3"/><rect x="19" y="45" width="7" height="12" fill="#B8B0A8" opacity="0.3"/><rect x="42" y="42" width="7" height="12" fill="#B8B0A8" opacity="0.3"/><rect x="53" y="42" width="7" height="12" fill="#B8B0A8" opacity="0.3"/><rect x="74" y="48" width="7" height="12" fill="#B8B0A8" opacity="0.3"/><rect x="85" y="48" width="7" height="12" fill="#B8B0A8" opacity="0.3"/><rect x="14" y="75" width="8" height="20" fill="#908880" opacity="0.35"/><rect x="46" y="70" width="8" height="25" fill="#908880" opacity="0.35"/><rect x="80" y="75" width="8" height="20" fill="#908880" opacity="0.35"/></svg>`,
                // Tower Bridge silhouette
                `<svg width="140" height="110" viewBox="0 0 140 110"><rect x="10" y="35" width="22" height="75" fill="#8090A0" opacity="0.4"/><rect x="108" y="35" width="22" height="75" fill="#8090A0" opacity="0.4"/><polygon points="21,35 10,20 32,20" fill="#8090A0" opacity="0.4"/><polygon points="119,35 108,20 130,20" fill="#8090A0" opacity="0.4"/><rect x="6" y="15" width="30" height="8" fill="#8090A0" opacity="0.4"/><rect x="104" y="15" width="30" height="8" fill="#8090A0" opacity="0.4"/><rect x="32" y="55" width="76" height="12" fill="#7888A0" opacity="0.35"/><path d="M 32 55 Q 70 35 108 55" stroke="#8090A0" stroke-width="4" fill="none" opacity="0.4"/><rect x="32" y="85" width="76" height="8" fill="#7888A0" opacity="0.35"/></svg>`,
                // St Paul's dome silhouette
                `<svg width="80" height="120" viewBox="0 0 80 120"><rect x="10" y="70" width="60" height="50" fill="#8898A8" opacity="0.4"/><ellipse cx="40" cy="50" rx="28" ry="25" fill="#8898A8" opacity="0.4"/><ellipse cx="40" cy="35" rx="12" ry="18" fill="#9098A8" opacity="0.4"/><rect x="36" y="10" width="8" height="12" fill="#8898A8" opacity="0.4"/><circle cx="40" cy="8" r="4" fill="#9098A8" opacity="0.35"/><rect x="15" y="80" width="8" height="12" fill="#98A0B0" opacity="0.3"/><rect x="57" y="80" width="8" height="12" fill="#98A0B0" opacity="0.3"/></svg>`,
                // The Shard silhouette
                `<svg width="35" height="150" viewBox="0 0 35 150"><polygon points="17.5,0 5,150 30,150" fill="#7888A0" opacity="0.4"/><line x1="17.5" y1="20" x2="17.5" y2="145" stroke="#8898B0" stroke-width="1" opacity="0.3"/><line x1="10" y1="50" x2="25" y2="50" stroke="#8898B0" stroke-width="1" opacity="0.25"/><line x1="8" y1="90" x2="27" y2="90" stroke="#8898B0" stroke-width="1" opacity="0.25"/></svg>`,
                // More townhouses with chimneys
                `<svg width="90" height="90" viewBox="0 0 90 90"><rect x="2" y="28" width="26" height="62" fill="#9898A0" opacity="0.42"/><rect x="30" y="32" width="28" height="58" fill="#A0A098" opacity="0.42"/><rect x="60" y="25" width="28" height="65" fill="#A898A0" opacity="0.42"/><rect x="8" y="18" width="4" height="12" fill="#707078" opacity="0.5"/><rect x="20" y="20" width="4" height="10" fill="#707078" opacity="0.5"/><rect x="38" y="22" width="4" height="12" fill="#707078" opacity="0.5"/><rect x="50" y="24" width="4" height="10" fill="#707078" opacity="0.5"/><rect x="68" y="15" width="4" height="12" fill="#707078" opacity="0.5"/><rect x="80" y="17" width="4" height="10" fill="#707078" opacity="0.5"/><rect x="6" y="42" width="6" height="10" fill="#B0A8A0" opacity="0.3"/><rect x="16" y="42" width="6" height="10" fill="#B0A8A0" opacity="0.3"/><rect x="36" y="46" width="6" height="10" fill="#B0A8A0" opacity="0.3"/><rect x="46" y="46" width="6" height="10" fill="#B0A8A0" opacity="0.3"/><rect x="66" y="40" width="6" height="10" fill="#B0A8A0" opacity="0.3"/><rect x="76" y="40" width="6" height="10" fill="#B0A8A0" opacity="0.3"/></svg>`
            ];
            const farBaseWidth = window.innerWidth;
            let x = 0;
            for (let i = 0; i < 8; i++) {
                const d = document.createElement('div');
                d.innerHTML = farSVGs[i % farSVGs.length];
                d.style.cssText = `position:absolute;left:${x}px;bottom:0`;
                far.appendChild(d);
                x += farBaseWidth / 8;
            }
            duplicateForSeamless(far, farBaseWidth);

            // MID LAYER - London cues: more phone boxes, cabs, lampposts, Underground signs
            const midSVGs = [
                // Red telephone box
                `<svg width="18" height="45" viewBox="0 0 18 45"><rect x="2" y="5" width="14" height="40" rx="1" fill="#CC2020" opacity="0.7"/><rect x="4" y="0" width="10" height="6" rx="1" fill="#CC2020" opacity="0.7"/><rect x="4" y="10" width="10" height="25" fill="#88AACC" opacity="0.4"/><rect x="6" y="12" width="2" height="8" fill="#6688AA" opacity="0.4"/><rect x="10" y="12" width="2" height="8" fill="#6688AA" opacity="0.4"/></svg>`,
                // Victorian lamppost
                `<svg width="14" height="60" viewBox="0 0 14 60"><rect x="5" y="18" width="4" height="42" fill="#2A2A2A" opacity="0.7"/><ellipse cx="7" cy="60" rx="6" ry="2" fill="#2A2A2A" opacity="0.6"/><path d="M 2 18 Q 2 8 7 6 Q 12 8 12 18" fill="#3A3A3A" opacity="0.7"/><ellipse cx="7" cy="10" rx="4" ry="5" fill="#FFE4A0" opacity="0.4"/><rect x="4" y="15" width="6" height="4" fill="#3A3A3A" opacity="0.7"/></svg>`,
                // Red double-decker bus
                `<svg width="55" height="38" viewBox="0 0 55 38"><rect x="4" y="12" width="47" height="26" rx="2" fill="#CC2020" opacity="0.75"/><rect x="4" y="5" width="40" height="14" rx="2" fill="#CC2020" opacity="0.75"/><rect x="8" y="8" width="8" height="8" fill="#88AACC" opacity="0.5"/><rect x="18" y="8" width="8" height="8" fill="#88AACC" opacity="0.5"/><rect x="28" y="8" width="8" height="8" fill="#88AACC" opacity="0.5"/><rect x="8" y="18" width="10" height="10" fill="#88AACC" opacity="0.5"/><rect x="22" y="18" width="10" height="10" fill="#88AACC" opacity="0.5"/><rect x="36" y="18" width="10" height="10" fill="#88AACC" opacity="0.5"/><circle cx="14" cy="36" r="3.5" fill="#222" opacity="0.8"/><circle cx="41" cy="36" r="3.5" fill="#222" opacity="0.8"/></svg>`,
                // Underground roundel sign
                `<svg width="24" height="55" viewBox="0 0 24 55"><rect x="10" y="25" width="4" height="30" fill="#1A1A1A" opacity="0.7"/><circle cx="12" cy="12" r="11" fill="none" stroke="#CC2020" stroke-width="4" opacity="0.75"/><rect x="2" y="8" width="20" height="8" fill="#1A3A6E" opacity="0.75"/></svg>`,
                // Black cab
                `<svg width="40" height="28" viewBox="0 0 40 28"><rect x="4" y="10" width="32" height="18" rx="3" fill="#1A1A1A" opacity="0.75"/><path d="M 8 10 Q 8 4 16 4 L 28 4 Q 32 4 32 10" fill="#1A1A1A" opacity="0.75"/><rect x="8" y="6" width="10" height="8" rx="1" fill="#88AACC" opacity="0.5"/><rect x="22" y="6" width="8" height="8" rx="1" fill="#88AACC" opacity="0.5"/><circle cx="10" cy="26" r="3" fill="#222" opacity="0.8"/><circle cx="30" cy="26" r="3" fill="#222" opacity="0.8"/></svg>`,
                // Victorian lamppost (duplicate for more density)
                `<svg width="14" height="60" viewBox="0 0 14 60"><rect x="5" y="18" width="4" height="42" fill="#2A2A2A" opacity="0.7"/><ellipse cx="7" cy="60" rx="6" ry="2" fill="#2A2A2A" opacity="0.6"/><path d="M 2 18 Q 2 8 7 6 Q 12 8 12 18" fill="#3A3A3A" opacity="0.7"/><ellipse cx="7" cy="10" rx="4" ry="5" fill="#FFE4A0" opacity="0.4"/><rect x="4" y="15" width="6" height="4" fill="#3A3A3A" opacity="0.7"/></svg>`,
                // Park tree
                `<svg width="35" height="55" viewBox="0 0 35 55"><rect x="14" y="35" width="6" height="20" fill="#5D4423" opacity="0.8"/><ellipse cx="17" cy="22" rx="15" ry="20" fill="#3A7A3A" opacity="0.7"/><ellipse cx="12" cy="18" rx="8" ry="10" fill="#4A8A4A" opacity="0.6"/></svg>`,
                // Postbox (iconic British red)
                `<svg width="16" height="35" viewBox="0 0 16 35"><rect x="2" y="8" width="12" height="27" rx="2" fill="#CC2020" opacity="0.75"/><ellipse cx="8" cy="8" rx="6" ry="4" fill="#CC2020" opacity="0.75"/><rect x="4" y="14" width="8" height="3" fill="#1A1A1A" opacity="0.4"/><ellipse cx="8" cy="6" rx="3" ry="2" fill="#DD3030" opacity="0.6"/></svg>`,
                // Wrought iron railing section
                `<svg width="45" height="30" viewBox="0 0 45 30"><rect x="0" y="5" width="45" height="3" fill="#1A1A1A" opacity="0.6"/><rect x="0" y="25" width="45" height="3" fill="#1A1A1A" opacity="0.6"/><rect x="2" y="5" width="2" height="23" fill="#1A1A1A" opacity="0.6"/><rect x="12" y="5" width="2" height="23" fill="#1A1A1A" opacity="0.6"/><rect x="22" y="5" width="2" height="23" fill="#1A1A1A" opacity="0.6"/><rect x="32" y="5" width="2" height="23" fill="#1A1A1A" opacity="0.6"/><rect x="42" y="5" width="2" height="23" fill="#1A1A1A" opacity="0.6"/><ellipse cx="7" cy="12" rx="3" ry="4" fill="none" stroke="#1A1A1A" stroke-width="1.5" opacity="0.5"/><ellipse cx="17" cy="12" rx="3" ry="4" fill="none" stroke="#1A1A1A" stroke-width="1.5" opacity="0.5"/><ellipse cx="27" cy="12" rx="3" ry="4" fill="none" stroke="#1A1A1A" stroke-width="1.5" opacity="0.5"/><ellipse cx="37" cy="12" rx="3" ry="4" fill="none" stroke="#1A1A1A" stroke-width="1.5" opacity="0.5"/></svg>`,
                // Black cab (another)
                `<svg width="40" height="28" viewBox="0 0 40 28"><rect x="4" y="10" width="32" height="18" rx="3" fill="#1A1A1A" opacity="0.75"/><path d="M 8 10 Q 8 4 16 4 L 28 4 Q 32 4 32 10" fill="#1A1A1A" opacity="0.75"/><rect x="8" y="6" width="10" height="8" rx="1" fill="#88AACC" opacity="0.5"/><rect x="22" y="6" width="8" height="8" rx="1" fill="#88AACC" opacity="0.5"/><circle cx="10" cy="26" r="3" fill="#222" opacity="0.8"/><circle cx="30" cy="26" r="3" fill="#222" opacity="0.8"/></svg>`
            ];
            const midBaseWidth = window.innerWidth;
            x = 0;
            for (let i = 0; i < 12; i++) {
                const d = document.createElement('div');
                d.innerHTML = midSVGs[i % midSVGs.length];
                d.style.cssText = `position:absolute;left:${x}px;bottom:0`;
                mid.appendChild(d);
                x += midBaseWidth / 12;
            }
            duplicateForSeamless(mid, midBaseWidth);

            // PARK LAYER - Hyde Park / Regent's Park feel
            const parkSVGs = [
                // Oak tree
                `<svg width="45" height="65" viewBox="0 0 45 65"><rect x="19" y="42" width="7" height="23" fill="#5D4423" opacity="0.85"/><ellipse cx="22" cy="26" rx="20" ry="24" fill="#3A7A32" opacity="0.8"/><ellipse cx="16" cy="22" rx="10" ry="12" fill="#4A8A42" opacity="0.7"/><ellipse cx="30" cy="28" rx="8" ry="10" fill="#4A8A42" opacity="0.7"/></svg>`,
                // Park bench
                `<svg width="45" height="32" viewBox="0 0 45 32"><rect x="4" y="18" width="3" height="14" fill="#1A1A1A" opacity="0.75"/><rect x="38" y="18" width="3" height="14" fill="#1A1A1A" opacity="0.75"/><rect x="0" y="10" width="45" height="10" fill="#5D4E37" rx="2" opacity="0.8"/><rect x="0" y="2" width="45" height="10" fill="#6B5D4D" rx="2" opacity="0.8"/></svg>`,
                // Flower bed
                `<svg width="35" height="18" viewBox="0 0 35 18"><ellipse cx="17" cy="14" rx="16" ry="4" fill="#5A4A3A" opacity="0.6"/><circle cx="8" cy="8" r="4" fill="#FF6090" opacity="0.7"/><circle cx="17" cy="6" r="4" fill="#FFD700" opacity="0.7"/><circle cx="26" cy="8" r="4" fill="#9070FF" opacity="0.7"/><circle cx="8" cy="8" r="2" fill="#FFD700" opacity="0.6"/><circle cx="17" cy="6" r="2" fill="#FF6090" opacity="0.6"/><circle cx="26" cy="8" r="2" fill="#FFD700" opacity="0.6"/></svg>`,
                // Decorative shrub
                `<svg width="28" height="22" viewBox="0 0 28 22"><ellipse cx="14" cy="15" rx="13" ry="8" fill="#3A8A32" opacity="0.8"/><ellipse cx="10" cy="12" rx="6" ry="5" fill="#4A9A42" opacity="0.7"/><ellipse cx="18" cy="12" rx="6" ry="5" fill="#4A9A42" opacity="0.7"/></svg>`,
                // Swan on water
                `<svg width="32" height="25" viewBox="0 0 32 25"><ellipse cx="18" cy="20" rx="13" ry="5" fill="#FFFFFF" opacity="0.85"/><path d="M 8 20 Q 4 14 8 8 Q 11 5 13 9" stroke="#FFFFFF" stroke-width="4" fill="none" opacity="0.85"/><ellipse cx="6" cy="8" rx="4" ry="3" fill="#FFFFFF" opacity="0.85"/><ellipse cx="4" cy="8" rx="2" ry="1.2" fill="#FF8C00" opacity="0.8"/><circle cx="6" cy="7" r="1" fill="#111" opacity="0.8"/></svg>`,
                // Small tree
                `<svg width="30" height="50" viewBox="0 0 30 50"><rect x="12" y="32" width="6" height="18" fill="#5D4423" opacity="0.85"/><ellipse cx="15" cy="20" rx="13" ry="18" fill="#3A7A32" opacity="0.8"/><ellipse cx="11" cy="17" rx="7" ry="9" fill="#4A8A42" opacity="0.7"/></svg>`,
                // Small duck
                `<svg width="20" height="16" viewBox="0 0 20 16"><ellipse cx="12" cy="11" rx="8" ry="5" fill="#8B6914" opacity="0.8"/><circle cx="5" cy="8" r="4" fill="#8B6914" opacity="0.8"/><ellipse cx="2" cy="9" rx="2.5" ry="1.5" fill="#FF8C00" opacity="0.8"/><circle cx="5" cy="7" r="1" fill="#111" opacity="0.8"/></svg>`,
                // Ornate fountain base
                `<svg width="40" height="40" viewBox="0 0 40 40"><ellipse cx="20" cy="36" rx="18" ry="4" fill="#909090" opacity="0.7"/><rect x="16" y="20" width="8" height="16" fill="#A0A0A0" opacity="0.7"/><ellipse cx="20" cy="20" rx="8" ry="3" fill="#A0A0A0" opacity="0.7"/><ellipse cx="20" cy="12" rx="3" ry="8" fill="#88BBDD" opacity="0.4"/></svg>`
            ];
            const parkBaseWidth = window.innerWidth;
            x = 0;
            for (let i = 0; i < 14; i++) {
                const d = document.createElement('div');
                d.innerHTML = parkSVGs[i % parkSVGs.length];
                d.style.cssText = `position:absolute;left:${x}px;bottom:0`;
                park.appendChild(d);
                x += parkBaseWidth / 14;
            }
            duplicateForSeamless(park, parkBaseWidth);
        }

        function initLives() {
            livesContainer.innerHTML = '';
            for (let i = 0; i < MAX_LIVES; i++) { // uses MAX_LIVES
                const b = document.createElement('div');
                b.className = 'life-bone';
                b.innerHTML = lifeBoneSVG;
                b.id = 'life-' + i;
                livesContainer.appendChild(b);
            }
        }

        function updateLives() {
            for (let i = 0; i < MAX_LIVES; i++) { // uses MAX_LIVES
                const b = document.getElementById('life-' + i);
                b.classList.toggle('lost', i >= lives);
            }
        }

        // Flying objects polish - map obstacle types to idle animation classes
        // ROSTER UPDATE: removed firework/hairdryer, added umbrella/frisbee
        const idleAnimations = {
            balloon: 'balloon-idle',
            pigeon: 'pigeon-idle',
            thunder: 'thunder-idle',
            vacuum: 'vacuum-idle',
            cat: 'cat-idle',
            squirrel: 'squirrel-idle',
            skateboard: 'skateboard-idle',
            umbrella: 'umbrella-idle',
            frisbee: 'frisbee-idle'
        };

        // Step 2.5 spawn pacing - PART 1: Calculate dynamic minimum spacing
        // Anti-cluster upgrade: nonlinear gameSpeed scaling for more aggressive spacing at high speeds
        // Difficulty curve: now uses tier-based multipliers for 3-act emotional arc
        function getMinSpacingPx(lastType, nextType) {
            // Get current difficulty tier
            const tier = getDifficultyTier(score);

            // Nonlinear gameSpeed scaling: spacing grows faster at higher speeds
            const speedMultiplier = Math.pow(gameSpeed, SPEED_EXPONENT);
            let spacing = BASE_REACTION_PX + (speedMultiplier * SPEED_FACTOR_PX);

            // Add width contribution from last obstacle
            if (lastType) {
                spacing += lastType.width * WIDTH_FACTOR;
            }

            // Step 2.5 spawn pacing - extra spacing for difficult combinations
            const lastIsAir = lastType && AIR_HAZARDS.includes(lastType.id);
            const nextIsAir = nextType && AIR_HAZARDS.includes(nextType.id);
            const lastIsTall = lastType && TALL_HAZARDS.includes(lastType.id);
            const nextIsTall = nextType && TALL_HAZARDS.includes(nextType.id);

            if (lastIsAir || nextIsAir) spacing += AIR_EXTRA_SPACING;
            if (lastIsTall || nextIsTall) spacing += TALL_EXTRA_SPACING;

            // Difficulty curve - apply tier-based spacing multiplier
            spacing *= getSpacingMultiplier(tier);

            // Difficulty curve - enforce minimum survivable gap (absolute floor)
            const minGap = getMinSurvivableGap(tier);
            spacing = Math.max(spacing, minGap);

            return spacing;
        }

        // Step 2.5 spawn pacing - PART 1: Get rightmost obstacle position
        function getRightmostObstacleX() {
            if (obstacles.length === 0) return -Infinity;
            return Math.max(...obstacles.map(o => o.x));
        }

        // Anti-cluster upgrade: frame counter for recovery window tracking
        let frameCount = 0;

        // Gameplay polish - Check if spawn would create impossible cluster
        // Applies hard minimum distance, recovery window spacing, and dynamic spacing rules
        function canSpawnObstacle(candidateType) {
            // Bones have their own safety check
            if (candidateType === null) return true;

            const rightmostX = getRightmostObstacleX();
            const spawnX = window.innerWidth + 80;
            const distanceFromSpawn = spawnX - rightmostX;
            const lastObs = obstacles.length > 0 ? obstacles[obstacles.length - 1] : null;
            const lastType = lastObs ? lastObs.type : null;
            const category = AIR_HAZARDS.includes(candidateType.id) ? 'air' : 'ground';

            // Gameplay polish - Hard safety rule: never spawn if too close to spawnX
            if (distanceFromSpawn < HARD_MIN_DISTANCE) {
                if (DEBUG) console.log(`[BLOCKED] id=${candidateType.id} cat=${category} speed=${gameSpeed.toFixed(2)} min=${HARD_MIN_DISTANCE} rightX=${rightmostX.toFixed(0)} spawnX=${spawnX} reason=hard_min`);
                return false;
            }

            // Gameplay polish - Calculate base minimum spacing
            let minSpacing = getMinSpacingPx(lastType, candidateType);

            // Gameplay polish - Recovery window after tall hazards applies to ALL obstacles
            const framesSinceTall = frameCount - lastTallSpawnFrame;
            const inRecovery = lastTallSpawnFrame > 0 && framesSinceTall < TALL_RECOVERY_FRAMES;
            if (inRecovery) {
                minSpacing += RECOVERY_EXTRA_SPACING;
            }

            const canSpawn = distanceFromSpawn >= minSpacing;

            if (DEBUG && !canSpawn) {
                const recStr = inRecovery ? ` recovery=${framesSinceTall}/${TALL_RECOVERY_FRAMES}` : '';
                console.log(`[BLOCKED] id=${candidateType.id} cat=${category} speed=${gameSpeed.toFixed(2)} min=${minSpacing.toFixed(0)} rightX=${rightmostX.toFixed(0)} spawnX=${spawnX}${recStr} reason=spacing`);
            }

            return canSpawn;
        }

        // Gameplay polish - Log successful spawn (called from spawnObstacle)
        function logSpawn(candidateType) {
            if (!DEBUG) return;
            const rightmostX = getRightmostObstacleX();
            const spawnX = window.innerWidth + 80;
            const lastObs = obstacles.length > 0 ? obstacles[obstacles.length - 1] : null;
            const lastType = lastObs ? lastObs.type : null;
            const category = AIR_HAZARDS.includes(candidateType.id) ? 'air' : 'ground';
            const minSpacing = getMinSpacingPx(lastType, candidateType);
            console.log(`[SPAWNED] id=${candidateType.id} cat=${category} speed=${gameSpeed.toFixed(2)} min=${minSpacing.toFixed(0)} rightX=${rightmostX.toFixed(0)} spawnX=${spawnX}`);
        }

        // Step 2.6 spawn gate accuracy - Get next candidate WITHOUT modifying state
        // Returns: obstacle type object, or null for "spawn bone", or undefined if pattern queue empty
        function peekPatternCandidate() {
            if (patternQueue.length === 0) return undefined;
            const patternType = patternQueue[0]; // Peek, don't shift
            if (patternType === 'bone') return null;
            return scaryThings.find(t => t.id === patternType) || undefined;
        }

        // Step 2.6 spawn gate accuracy - Select obstacle based on fairness rules (no pattern queue)
        // Difficulty curve: now uses tier-based hazard probabilities
        function selectRandomFairObstacle() {
            const now = Date.now();
            const tier = getDifficultyTier(score);
            let candidates = [...scaryThings];

            // Difficulty curve - get tier-specific hazard chances
            let airChance, tallChance;
            switch (tier) {
                case 'EARLY':
                    airChance = AIR_HAZARD_CHANCE_EARLY;
                    tallChance = TALL_HAZARD_CHANCE_EARLY;
                    break;
                case 'MID':
                    airChance = AIR_HAZARD_CHANCE_MID;
                    tallChance = TALL_HAZARD_CHANCE_MID;
                    break;
                case 'LATE':
                    airChance = AIR_HAZARD_CHANCE_LATE;
                    tallChance = TALL_HAZARD_CHANCE_LATE;
                    break;
                default:
                    airChance = AIR_HAZARD_CHANCE_MID;
                    tallChance = TALL_HAZARD_CHANCE_MID;
            }

            // Difficulty curve - post-hard-hazard: prefer small hazards
            const timeSinceHard = now - lastHardHazardTime;
            const inPostHardWindow = lastHardHazardTime > 0 && timeSinceHard < 1500;
            if (inPostHardWindow && Math.random() < POST_HARD_SMALL_ONLY_CHANCE) {
                const smallOnly = candidates.filter(t => SMALL_HAZARDS.includes(t.id));
                if (smallOnly.length > 0) {
                    if (DEBUG_DIFFICULTY) console.log('[DIFFICULTY] Post-hard breather: forcing small hazard');
                    candidates = smallOnly;
                }
            }

            // Step 2.5 spawn pacing - PART 2: Never two air hazards back-to-back
            if (lastSpawnedCategory === 'air') {
                candidates = candidates.filter(t => !AIR_HAZARDS.includes(t.id));
            }

            // Step 2.5 spawn pacing - filter out air hazards if cooldown hasn't passed
            if (now - lastAirSpawnTime < AIR_COOLDOWN) {
                candidates = candidates.filter(t => !AIR_HAZARDS.includes(t.id));
            }

            // Step 2.5 spawn pacing - filter out tall hazards if cooldown hasn't passed
            if (now - lastTallSpawnTime < TALL_COOLDOWN) {
                candidates = candidates.filter(t => !TALL_HAZARDS.includes(t.id));
            }

            // Step 2.5 spawn pacing - avoid same type twice in a row
            if (lastSpawnedType && candidates.length > 1) {
                candidates = candidates.filter(t => t.id !== lastSpawnedType);
            }

            // Step 2.5 spawn pacing - prefer variety: if last was tall, prefer small
            if (TALL_HAZARDS.includes(lastSpawnedType) && candidates.length > 2) {
                const smallCandidates = candidates.filter(t => SMALL_HAZARDS.includes(t.id));
                if (smallCandidates.length > 0 && Math.random() < 0.7) {
                    candidates = smallCandidates;
                }
            }

            // Fallback to full list if too filtered
            if (candidates.length === 0) candidates = [...scaryThings];

            // Difficulty curve - tier-based hazard type weighting
            // Separate candidates into categories and apply weighted selection
            const airCandidates = candidates.filter(t => AIR_HAZARDS.includes(t.id));
            const tallCandidates = candidates.filter(t => TALL_HAZARDS.includes(t.id) && !AIR_HAZARDS.includes(t.id));
            const smallCandidates = candidates.filter(t => SMALL_HAZARDS.includes(t.id));
            const otherCandidates = candidates.filter(t =>
                !AIR_HAZARDS.includes(t.id) && !TALL_HAZARDS.includes(t.id) && !SMALL_HAZARDS.includes(t.id)
            );

            // Weighted random selection based on tier probabilities
            const roll = Math.random();
            let selectedPool;

            if (roll < airChance && airCandidates.length > 0) {
                selectedPool = airCandidates;
            } else if (roll < airChance + tallChance && tallCandidates.length > 0) {
                selectedPool = tallCandidates;
            } else if (smallCandidates.length > 0) {
                // Prefer small hazards for remaining probability
                selectedPool = smallCandidates;
            } else {
                // Fallback to any remaining candidates
                selectedPool = candidates;
            }

            return selectedPool[Math.floor(Math.random() * selectedPool.length)];
        }

        // Step 2.6 spawn gate accuracy - Unified candidate selection
        // Returns obstacle type object or null (for bone)
        // This is called once per spawn attempt and used for both gating AND spawning
        let cachedNextCandidate = null;
        let candidateCacheValid = false;

        function getNextObstacleCandidate() {
            // Step 2.6 spawn gate accuracy - Return cached candidate if valid
            if (candidateCacheValid) return cachedNextCandidate;

            // Step 2.6 spawn gate accuracy - Check pattern queue first
            const patternCandidate = peekPatternCandidate();
            if (patternCandidate !== undefined) {
                cachedNextCandidate = patternCandidate; // Could be obstacle type or null (bone)
                candidateCacheValid = true;
                return cachedNextCandidate;
            }

            // Step 2.6 spawn gate accuracy - No pattern, use fair random selection
            cachedNextCandidate = selectRandomFairObstacle();
            candidateCacheValid = true;
            return cachedNextCandidate;
        }

        // Step 2.6 spawn gate accuracy - Invalidate cache after spawn or each frame
        function invalidateCandidateCache() {
            candidateCacheValid = false;
            cachedNextCandidate = null;
        }

        // Step 2.5 spawn pacing - PART 2: Generate rhythm pattern at milestones
        function maybeQueuePattern() {
            // Only trigger at score milestones and if queue is empty
            if (patternQueue.length > 0) return;
            if (score > 0 && score % PATTERN_SCORE_INTERVAL < 15 && Math.random() < 0.4) {
                // Pattern: ground -> ground -> air -> (optional bone)
                const groundOptions = SMALL_HAZARDS.filter(id => id !== lastSpawnedType);
                const g1 = groundOptions[Math.floor(Math.random() * groundOptions.length)] || 'pigeon';
                const g2 = groundOptions.filter(id => id !== g1)[Math.floor(Math.random() * (groundOptions.length - 1))] || 'squirrel';
                const airOptions = AIR_HAZARDS;
                const a1 = airOptions[Math.floor(Math.random() * airOptions.length)];

                patternQueue.push(g1, g2, a1);
                if (Math.random() < 0.5) patternQueue.push('bone');
                // Step 2.6 spawn gate accuracy - invalidate cache when pattern queued
                invalidateCandidateCache();
            }
        }

        // Step 2.6 spawn gate accuracy - Consume pattern queue item (only call when actually spawning)
        function consumePatternQueueItem() {
            if (patternQueue.length > 0) {
                patternQueue.shift();
            }
        }

        // Step 2.6 spawn gate accuracy - spawnObstacle now accepts type parameter
        function spawnObstacle(t) {
            // Step 2.6 spawn gate accuracy - if null passed, spawn bone instead (pattern request)
            if (t === null) {
                consumePatternQueueItem();
                spawnPowerup();
                invalidateCandidateCache();
                return;
            }

            const now = Date.now();

            // Step 2.6 spawn gate accuracy - update tracking correctly
            if (AIR_HAZARDS.includes(t.id)) {
                lastAirSpawnTime = now;
                lastSpawnedCategory = 'air';
            } else {
                lastSpawnedCategory = 'ground';
            }
            if (TALL_HAZARDS.includes(t.id)) {
                lastTallSpawnTime = now;
                lastTallSpawnFrame = frameCount; // Anti-cluster: track frame for recovery window
            }
            lastSpawnedType = t.id;
            consecutiveSpawns++;

            // Gameplay polish - log spawn decision when DEBUG is enabled
            logSpawn(t);

            // Step 2.6 spawn gate accuracy - consume pattern queue if this was a pattern spawn
            consumePatternQueueItem();

            const o = document.createElement('div');
            o.className = 'obstacle';

            // Flying objects polish - wrap SVG in sprite div for animations (preserves hitbox)
            const sprite = document.createElement('div');
            const idleClass = idleAnimations[t.id] || 'default-idle';
            sprite.className = 'sprite spawning';
            sprite.innerHTML = t.svg;
            o.appendChild(sprite);

            // CHANGE (visual): use transform for smoother movement - set right:0 as anchor
            o.style.cssText = `width:${t.width}px;height:${t.height}px;right:0;bottom:${t.groundY}%;will-change:transform`;
            obstaclesContainer.appendChild(o);

            // Flying objects polish - animation sequence: spawn -> telegraph -> idle
            setTimeout(() => {
                sprite.classList.remove('spawning');
                sprite.classList.add('telegraph');
                setTimeout(() => {
                    sprite.classList.remove('telegraph');
                    sprite.classList.add(idleClass);
                }, 200);
            }, 150);

            obstacles.push({ element: o, x: window.innerWidth + 80, type: t, hit: false });

            // Step 2.6 spawn gate accuracy - invalidate cache after spawning
            invalidateCandidateCache();
        }

        // Step 2.7 powerup safety - Check if bone spawn position is safe
        function isBonePositionSafe(boneHeight) {
            const boneSpawnX = window.innerWidth + 200;
            // Step 2.7 powerup safety - tuned safe distances
            const safeDistanceBehind = 120; // Don't spawn too close behind obstacle
            const safeDistanceAhead = 280;  // Don't spawn if obstacle will overlap soon

            for (const o of obstacles) {
                // Step 2.7 powerup safety - check if obstacle is too close behind spawn point
                if (o.x > boneSpawnX - safeDistanceBehind && o.x < boneSpawnX + 60) {
                    return false;
                }
                // Step 2.7 powerup safety - check if obstacle will reach bone's position while bone is still there
                if (o.x > boneSpawnX && o.x < boneSpawnX + safeDistanceAhead) {
                    // Check vertical overlap potential
                    const obsBottomPct = o.type.groundY;
                    const obsTopPct = obsBottomPct + (o.type.height / window.innerHeight) * 100;
                    // Bone heights are 18, 25, 32 percent - use 6% margin for safety
                    if (boneHeight >= obsBottomPct - 6 && boneHeight <= obsTopPct + 6) {
                        return false;
                    }
                }
            }
            return true;
        }

        // ========================================================================
        // POWERUP SPAWN TUNING (single source of truth)
        // Bone spawn chance decreases with score for mid-run tension.
        // CHANGE (cleanup): removed duplicate legacy blocks; single source of truth
        // ========================================================================

        // Step 2.7 powerup safety - available bone heights
        const BONE_HEIGHTS = [18, 25, 32];

        // Bone spawn scales down with score - tuned for mid-run tension (~250-400)
        // Returns spawn chance (0-1) and cooldown multiplier based on current score
        function getBoneSpawnChance(currentScore) {
            // Early game (< 150): generous bones to help learning
            if (currentScore < 150) {
                return { chance: 1.0, cooldownMult: 1.0 };
            }
            // CHANGE (difficulty): tighten bone scarcity curve (one notch) - was 0.80/1.20
            // Mid-early (150-300): reduced ~12% for mid-run tension
            if (currentScore < 300) {
                return { chance: 0.70, cooldownMult: 1.30 };
            }
            // CHANGE (difficulty): tighten bone scarcity curve (one notch) - was 0.55/1.40
            // Mid game (300-450): reduced ~10% for sustained tension
            if (currentScore < 450) {
                return { chance: 0.50, cooldownMult: 1.55 };
            }
            // Late game (> 450): notably reduced (unchanged from previous tightening)
            return { chance: 0.30, cooldownMult: 1.80 };
        }

        // Step 2.7 powerup safety - find a safe height for bone spawn
        function findSafeBoneHeight() {
            // Try up to 5 random heights to find a safe one
            for (let attempt = 0; attempt < 5; attempt++) {
                const candidateHeight = BONE_HEIGHTS[Math.floor(Math.random() * BONE_HEIGHTS.length)];
                if (isBonePositionSafe(candidateHeight)) {
                    return candidateHeight;
                }
            }
            return null; // No safe height found after 5 attempts
        }

        // Step 2.7 powerup safety - spawnPowerup accepts optional height parameter
        function spawnPowerup(preChosenHeight) {
            // Step 2.7 powerup safety - use pre-chosen height or find one
            let chosenHeight = preChosenHeight;
            if (chosenHeight === undefined) {
                // Fallback: find safe height internally (backwards compatibility)
                chosenHeight = findSafeBoneHeight();
            }

            // Step 2.7 powerup safety - skip spawn if no safe position
            if (chosenHeight === null) return false;

            const p = document.createElement('div');
            p.className = 'powerup';

            // Flying objects polish - wrap SVG in sprite div for animations (preserves hitbox)
            const sprite = document.createElement('div');
            sprite.className = 'sprite spawning';
            sprite.innerHTML = boneSVG;
            p.appendChild(sprite);

            // CHANGE (visual): use transform for smoother movement - set right:0 as anchor
            p.style.cssText = `width:45px;height:26px;right:0;bottom:${chosenHeight}%;will-change:transform`;
            obstaclesContainer.appendChild(p);

            // Flying objects polish - animation sequence: spawn -> idle with float+glow
            setTimeout(() => {
                sprite.classList.remove('spawning');
                sprite.classList.add('bone-idle');
            }, 150);

            powerups.push({ element: p, x: window.innerWidth + 200, collected: false, height: chosenHeight });
            return true; // Step 2.7 powerup safety - indicate successful spawn
        }

        // ========================================================================
        // MOTION SMOOTHING PASS (2026-01-22)
        // - GPU-accelerated movement via translate3d (not style.right)
        // - will-change: transform set on spawn (lines 3277, 3380)
        // - Substep collision checks at high speed for accuracy
        //
        // SANITY CHECK: Smoother motion can make the game FEEL harder because:
        // 1. Players see obstacles more clearly (less motion blur/strobing)
        // 2. Collision feedback is more precise (no "I dodged that!" frustration)
        // 3. High-speed sections appear faster/more intense visually
        // This is a PERCEIVED difficulty increase, not a mechanical one.
        // No spawn rates, physics, or scoring were changed.
        // ========================================================================

        // CHANGE (visual): high-speed substep motion smoothing to reduce strobing
        // When spd > 10, split movement into substeps for smoother collision and visual continuity
        const SUBSTEP_THRESHOLD = 10;  // px/frame threshold to enable substeps
        const MAX_SUBSTEPS = 1; // v1.1 perf: disable substeps (avoid layout thrash);        // cap to avoid performance issues

        function updateObstacles() {
            const spd = 5 * gameSpeed;
            const tr = taterContainer.getBoundingClientRect();
            const hb = { left: tr.left + 20, right: tr.right - 15, top: tr.top + 15, bottom: tr.bottom - 12 };

            // Calculate substeps: 1 step if slow, up to MAX_SUBSTEPS if fast
            const numSteps = spd > SUBSTEP_THRESHOLD ? Math.min(MAX_SUBSTEPS, Math.ceil(spd / SUBSTEP_THRESHOLD)) : 1;
            const stepSize = spd / numSteps;

            obstacles = obstacles.filter(o => {
                // Substep movement with per-step collision checks
                for (let step = 0; step < numSteps; step++) {
                    o.x -= stepSize;
                    // Check collision at each substep for accuracy
                    if (!o.hit && !invulnerable) {
                        // Update transform for accurate getBoundingClientRect
                        o.element.style.transform = `translate3d(${o.x - window.innerWidth}px, 0, 0)`;
                        const or = o.element.getBoundingClientRect();
                        if (hb.left < or.right - 8 && hb.right > or.left + 8 && hb.top < or.bottom - 8 && hb.bottom > or.top + 8) {
                            o.hit = true;
                            takeDamage();
                            break; // Stop substeps after hit
                        }
                    }
                }
                // Final position update (GPU-accelerated)
                o.element.style.transform = `translate3d(${o.x - window.innerWidth}px, 0, 0)`;
                if (!o.scored && o.x < tr.left - 40) {
                    o.scored = true;
                    score += Math.floor(10 * gameSpeed);
                    scoreDisplay.textContent = score;
                    updateJourneyDisplay(score); // Journey framing
                    updateTaterTiredState(score); // Priority 3: Emotional feedback
                }
                if (o.x < -100) { o.element.remove(); return false; }
                return true;
            });

            powerups = powerups.filter(p => {
                // Substep movement with per-step collision checks
                for (let step = 0; step < numSteps; step++) {
                    p.x -= stepSize;
                    // Check collision at each substep for accuracy
                    if (!p.collected) {
                        // Update transform for accurate getBoundingClientRect
                        p.element.style.transform = `translate3d(${p.x - window.innerWidth}px, 0, 0)`;
                        const pr = p.element.getBoundingClientRect();
                        if (hb.left < pr.right && hb.right > pr.left && hb.top < pr.bottom && hb.bottom > pr.top) {
                            p.collected = true;
                            collectPowerup(p);
                            break; // Stop substeps after collection
                        }
                    }
                }
                // Final position update (GPU-accelerated)
                p.element.style.transform = `translate3d(${p.x - window.innerWidth}px, 0, 0)`;
                if (p.x < -50) { p.element.remove(); return false; }
                return true;
            });
        }

        function collectPowerup(p) {
            // Step 3 juice - bone pop animation before removal
            const sprite = p.element.querySelector('.sprite');
            if (sprite) sprite.classList.add('collected');

            // Step 3 sound - play collect sound
            playHealOrCollect();

            if (lives < MAX_LIVES) { // uses MAX_LIVES
                lives++;
                updateLives();
                healFlash.classList.add('show');
                setTimeout(() => healFlash.classList.remove('show'), 180);
                tater.classList.remove('running');
                tater.classList.add('healed');
                setTimeout(() => { tater.classList.remove('healed'); if (!isJumping && !isGameOver) tater.classList.add('running'); }, 500);

                // Step 3 juice - floating "+1" text near Tater
                const tr = taterContainer.getBoundingClientRect();
                showFloatText('+1', tr.left + tr.width / 2, tr.top - 10);
            }
            score += 20;
            scoreDisplay.textContent = score;
            updateJourneyDisplay(score); // Journey framing
            updateTaterTiredState(score); // Priority 3: Emotional feedback

            // Onboarding - show first bone collected toast
            if (!toastShownBone) {
                toastShownBone = true;
                localStorage.setItem('taterToastBone', 'true');
                setTimeout(() => showToast('Bones heal you ðŸ¦´', 2000), 300);
            }

            // Remove element after pop animation completes
            setTimeout(() => p.element.remove(), 150);
        }

        function takeDamage() {
            lives--;
            updateLives();

            // Step 3 sound - play hit sound
            playHit();

            // Step 3 juice - screen shake
            gameContainer.classList.add('shake');
            setTimeout(() => gameContainer.classList.remove('shake'), 100);

            // Step 3 juice - hit-stop (100ms pause of game updates)
            hitStopUntil = Date.now() + 100;

            damageFlash.classList.add('show');
            setTimeout(() => damageFlash.classList.remove('show'), 120);
            tater.classList.remove('running');
            tater.classList.add('hurt');
            setTimeout(() => { tater.classList.remove('hurt'); if (!isGameOver && !isJumping) tater.classList.add('running'); }, 500);
            invulnerable = true;
            setTimeout(() => invulnerable = false, 1000);
            if (lives <= 0) gameOver();
        }

        // Step 1.1 fix: Always set isHolding so releaseJump can run and buffer jumps while airborne
        function startJump() {
            // Step 4 tutorial - don't start jump while tutorial is active
            if (isPaused || isGameOver || tutorialActive) return;
            startPrompt.classList.remove('show');
            // Visual hierarchy & pacing - Part B: First input starts the run
            if (preRunState) {
                preRunState = false;
                if (DEBUG_START) console.log('[DEBUG] preRunState -> false, starting run');
                startPrompt.classList.remove('show');
                // Onboarding - hide hint bar when run begins (Mode B: no persistent hint during play)
                hideHintBar();
                body.classList.add('playing'); // Visual hierarchy & pacing - Part A
                tater.classList.add('running');
                pauseAnimations(false);
            }
            isHolding = true;
            jumpPower = 0;
        }
        // Step 1.1 fix: Only charge jumpPower when grounded or in coyote time, preserving hold-to-charge mechanic
        function updateJumpCharge() {
            if (!isHolding) return;
            const now = Date.now();
            const canCharge = !isJumping || (now - lastGroundedTime < COYOTE_TIME);
            if (canCharge) {
                jumpPower = Math.min(jumpPower + 4, 100);
                jumpIndicator.style.height = (jumpPower * 0.6) + 'px';
            }
        }
        // Step 1.1 fix: Remove jumpPower > 5 check so short taps use MIN_JUMP_VELOCITY
        // Step 1.1 fix: Always record buffer time when releasing while airborne
        function releaseJump() {
            if (!isHolding) return;
            isHolding = false;
            const now = Date.now();

            // Check if we can jump now (on ground or within coyote time)
            const canJumpNow = !isJumping || (now - lastGroundedTime < COYOTE_TIME);

            if (canJumpNow) {
                // Execute jump immediately with charged velocity or minimum for short taps
                isJumping = true;
                const chargedVelocity = (jumpPower / 100) * 160 / 12;
                velocity = Math.max(MIN_JUMP_VELOCITY, chargedVelocity);
                tater.classList.remove('running');
                // Step 3 sound - play jump sound
                playJump();
                // Onboarding - show first jump toast (delayed to not interrupt)
                if (!toastShownJump) {
                    toastShownJump = true;
                    localStorage.setItem('taterToastJump', 'true');
                    setTimeout(() => showToast('Nice! Hold longer to jump higher', 2500), 800);
                }
            } else {
                // Step 1.1 fix: Buffer the jump for when we land (works for both holds and taps while airborne)
                jumpBufferTime = now;
            }

            jumpPower = 0;
            jumpIndicator.style.height = '0px';
        }

        // Jump feel improvement - asymmetric gravity creates satisfying arc (floaty peak, snappy fall)
        function updatePhysics() {
            const now = Date.now();

            if (isJumping) {
                // Apply asymmetric gravity: gentler while rising, stronger while falling
                // This creates an ease-out feel on ascent and snappier descent
                const gravity = velocity > 0 ? GRAVITY_UP : GRAVITY_DOWN;
                velocity -= gravity;

                taterY += velocity;

                if (taterY <= 0) {
                    // Landing - record grounded time and check for buffered jump
                    taterY = 0;
                    velocity = 0;
                    isJumping = false;
                    lastGroundedTime = now;

                    // Step 3 sound - play land sound
                    playLand();

                    // Jump buffering: if player released jump just before landing, execute it now
                    if (now - jumpBufferTime < JUMP_BUFFER_TIME) {
                        isJumping = true;
                        velocity = MIN_JUMP_VELOCITY; // Use minimum for buffered jumps
                        jumpBufferTime = 0; // Clear the buffer
                        // Step 3 sound - play jump sound for buffered jump
                        playJump();
                    } else if (!isPaused && !isGameOver) {
                        tater.classList.add('running');
                    }
                }

                taterContainer.style.bottom = (baseY + (taterY / window.innerHeight) * 100) + '%';
                const s = Math.max(0.3, 1 - (taterY / 150));
                shadow.style.transform = `scale(${s})`;
                shadow.style.opacity = s * 0.3;
            } else {
                // On ground - keep tracking grounded time for coyote time
                lastGroundedTime = now;
            }
        }

        // Journey framing v2 - Reflective, gentle game-over messages
        // Focus on progress toward home, not failure or conquest
        // CHANGE (story): home clarity â€” special message when player reached final stage
        function getGameOverMessage(finalScore) {
            // Final stage threshold (Almost Home) - acknowledge they made it
            if (finalScore >= 1900) return "He made it home today.";
            if (finalScore < 50) return "A short walk, but a start.";
            if (finalScore < 200) return "He found his bearings.";
            if (finalScore < 450) return "A little further this time.";
            if (finalScore < 800) return "He's learning the way.";
            if (finalScore < 1300) return "So close to familiar streets.";
            return "Almost home. Almost.";
        }

        // Game-over polish - Part D: Best score management
        // Journey framing - simplified to just manage localStorage (UI handled by updateGameOverJourney)
        function updateBestScore(currentScore) {
            const storedBest = parseInt(localStorage.getItem('taterBestScore') || '0', 10);
            const isNewBest = currentScore > storedBest;
            if (isNewBest) {
                localStorage.setItem('taterBestScore', currentScore.toString());
            }
            return isNewBest;
        }

        // Game-over polish - Enhanced game over with cinematic effects
        function gameOver() {
            isGameOver = true;
            body.classList.remove('playing'); // Visual hierarchy & pacing - restore UI

            // Game-over polish - Part C: Tater's defeated reaction
            tater.classList.remove('running', 'hurt');
            tater.classList.add('defeated');

            // Game-over polish - Part B: Cinematic framing
            gameContainer.classList.add('defeat-cinematic');
            vignetteOverlay.classList.add('show');

            // Game-over polish - Part D: Update score and message
            finalScoreDisplay.textContent = score;
            gameOverMessage.textContent = getGameOverMessage(score);
            // CHANGE (story): home clarity â€” softer title when player reached final stage
            gameOverTitle.textContent = score >= 1900 ? 'Home' : 'Oh no!';
            updateBestScore(score);
            updateGameOverJourney(score); // Journey framing - update journey display

            // Journey framing - hide milestone banner if showing
            if (milestoneBannerTimeout) {
                clearTimeout(milestoneBannerTimeout);
                milestoneBannerTimeout = null;
            }
            milestoneBanner.classList.remove('show');

            playGameOver();

            // Game-over polish - Part A: Brief defeat beat before showing overlay
            const reduceMotion = body.classList.contains('reduce-motion');
            const delay = reduceMotion ? 100 : 300;
            setTimeout(() => {
                gameOverOverlay.classList.add('show');
                pauseAnimations(true);

                // Priority 3: Emotional feedback - Hopeful beat after overlay appears
                // Subtle lift implying "we'll try again" - skip if reduce-motion
                if (!reduceMotion) {
                    taterHopefulTimeout = setTimeout(() => {
                        tater.classList.add('hopeful');
                    }, 600);
                }
            }, delay);
        }
        // Mobile UI - updated to preserve icon/label spans
        // Visual hierarchy & pacing - Part A: toggle playing class when pausing
        function togglePause() { if (isGameOver || preRunState) return; isPaused = !isPaused; pauseOverlay.classList.toggle('show', isPaused); pauseAnimations(isPaused); body.classList.toggle('playing', !isPaused); const pauseBtn = document.getElementById('pauseBtn'); const icon = isPaused ? 'â–¶' : 'â¸'; const label = isPaused ? 'Resume' : 'Pause'; pauseBtn.innerHTML = `<span class="btn-icon">${icon}</span><span class="btn-label">${label}</span>`; }
        // Visual hierarchy & pacing - Part B: also check preRunState before adding running class
        function pauseAnimations(p) { document.querySelectorAll('.clouds,.landmarks-far,.landmarks-mid,.park-elements,.path').forEach(e => e.classList.toggle('paused', p)); if (p) tater.classList.remove('running'); else if (!isJumping && !isGameOver && !preRunState) tater.classList.add('running'); }

        // Step 4 tutorial - show tutorial on first run
        function showTutorial() {
            if (tutorialActive) {
                tutorialOverlay.classList.add('show');
                pauseAnimations(true);
            }
        }

        // Step 4 tutorial - dismiss tutorial and start game
        function dismissTutorial() {
            tutorialActive = false;
            isPaused = false; // UI polish - ensure game unpauses (for Help reopen case)
            localStorage.setItem('taterTutorialSeen', 'true');
            tutorialOverlay.classList.remove('show');
            // Onboarding - show pre-run hint if still in pre-run, otherwise hide
            if (preRunState) {
                showPreRunHint();
                startPrompt.classList.add('show');
            } else {
                hideHintBar();
            }
            pauseAnimations(false);
        }

        // UI polish - show help (tutorial) without re-enabling hint
        function showHelp() {
            settingsOverlay.classList.remove('show'); // Close settings first
            isPaused = true; // Pause game logic while help is showing
            startPrompt.classList.remove('show'); // Visual hierarchy & pacing - hide prompt during help
            tutorialOverlay.classList.add('show');
            pauseAnimations(true);
        }

        function resetGame() {
            score = 0; lives = MAX_LIVES; gameSpeed = 1; isGameOver = false; isPaused = false; isJumping = false; isHolding = false; jumpPower = 0; velocity = 0; taterY = 0; invulnerable = false; // uses MAX_LIVES
            // Visual hierarchy & pacing - Part B: Reset to pre-run state
            preRunState = true;
            body.classList.remove('playing');
            startPrompt.classList.add('show');
            // Onboarding - show pre-run hint on reset (Mode A)
            showPreRunHint();
            // CHANGE (emotion): clear all Tater mood classes on restart (uses TATER_MOOD_CLASSES)
            resetTaterEmotionalState();
            // Game-over polish - Clear cinematic effects
            gameContainer.classList.remove('defeat-cinematic');
            vignetteOverlay.classList.remove('show');
            // Step 2.6 spawn gate accuracy - reset spawn tracking
            lastAirSpawnTime = 0; lastTallSpawnTime = 0; consecutiveSpawns = 0; lastSpawnedType = null; lastSpawnedCategory = null; patternQueue = [];
            // Difficulty curve - reset hard hazard tracking
            lastHardHazardTime = 0; lastLoggedTier = null;
            invalidateCandidateCache(); // Step 2.6 spawn gate accuracy
            scoreDisplay.textContent = '0'; updateLives();
            resetJourneyState(); // Journey framing - reset location display and milestone tracking
            obstacles.forEach(o => o.element.remove()); obstacles = [];
            powerups.forEach(p => p.element.remove()); powerups = [];
            pauseOverlay.classList.remove('show'); gameOverOverlay.classList.remove('show');
            // Mobile UI - reset pause button with icon/label spans
            document.getElementById('pauseBtn').innerHTML = '<span class="btn-icon">â¸</span><span class="btn-label">Pause</span>';
            jumpIndicator.style.height = '0px'; taterContainer.style.bottom = baseY + '%';
            shadow.style.transform = 'scale(1)'; shadow.style.opacity = '0.3';
            // Visual hierarchy & pacing - Part B: Tater idle, gentle background movement
            pauseAnimations(false); // Background moves gently during pre-run, Tater stays idle
        }

        function gameLoop() {
            const now = Date.now();
            // Step 3 juice - skip game updates during hit-stop (CSS animations continue)
            const inHitStop = now < hitStopUntil;

            // Step 4 tutorial - skip updates while tutorial is active
            // Visual hierarchy & pacing - Part B: skip updates during pre-run state
            if (!isPaused && !isGameOver && !inHitStop && !tutorialActive && !preRunState) {
                frameCount++; // Anti-cluster: increment frame counter for recovery tracking
                updateJumpCharge(); updatePhysics(); updateObstacles();

                // Step 2.5 spawn pacing - check for pattern queue opportunity
                maybeQueuePattern();

                // Difficulty curve - get current tier for spawn timing
                const tier = getDifficultyTier(score);
                const spawnParams = getSpawnDelayParams(tier);
                const maxConsecutive = getMaxConsecutive(tier);

                // Difficulty curve - calculate spawn interval with smooth progression within tier
                // Uses tier base/min with linear interpolation based on progress through tier
                let tierProgress = 0;
                if (tier === 'EARLY') {
                    tierProgress = score / TIER_EARLY_END;
                } else if (tier === 'MID') {
                    tierProgress = (score - TIER_EARLY_END) / (TIER_MID_END - TIER_EARLY_END);
                } else {
                    // LATE tier: asymptotic approach to min
                    tierProgress = Math.min(1, (score - TIER_MID_END) / 800);
                }
                let baseSpawnInterval = spawnParams.base - (spawnParams.base - spawnParams.min) * tierProgress;

                // Step 2.5 spawn pacing - add breather delay after consecutive spawns (tier-scaled)
                if (consecutiveSpawns >= maxConsecutive) {
                    baseSpawnInterval += BREATHER_DELAY;
                }

                // Difficulty curve - post-hard-hazard breather
                const timeSinceHardHazard = now - lastHardHazardTime;
                let postHardBreather = false;
                if (lastHardHazardTime > 0 && timeSinceHardHazard < POST_HARD_BREATHER_DELAY + 500) {
                    baseSpawnInterval += POST_HARD_BREATHER_DELAY;
                    postHardBreather = true;
                }

                // Step 2.6 spawn gate accuracy - get actual next candidate for spacing check
                const nextCandidate = getNextObstacleCandidate();

                // Step 2.6 spawn gate accuracy - use actual candidate type for spacing gate
                const canSpawn = canSpawnObstacle(nextCandidate);

                // Difficulty curve - debug logging
                if (DEBUG_DIFFICULTY && canSpawn && now - lastSpawnTime > baseSpawnInterval) {
                    const minSpacing = nextCandidate ? getMinSpacingPx(obstacles.length > 0 ? obstacles[obstacles.length - 1].type : null, nextCandidate) : 0;
                    logDifficulty(tier, gameSpeed, minSpacing, baseSpawnInterval, postHardBreather ? ' [post-hard breather]' : '');
                }

                if (now - lastSpawnTime > baseSpawnInterval && canSpawn) {
                    // Difficulty curve - track hard hazard spawns for breather logic
                    if (nextCandidate && isHardHazard(nextCandidate)) {
                        lastHardHazardTime = now;
                    }

                    // Step 2.6 spawn gate accuracy - spawn the same candidate we checked
                    spawnObstacle(nextCandidate);
                    lastSpawnTime = now;
                    // Step 2.5 spawn pacing - reset breather counter after breather (tier-scaled)
                    if (consecutiveSpawns >= maxConsecutive) consecutiveSpawns = 0;
                }

                // Step 2.7 powerup safety - improved powerup spawn timing
                // CHANGE (difficulty): bone spawn chance and cooldown scale with score
                const boneSpawnParams = getBoneSpawnChance(score);
                const baseCooldown = (8000 + Math.random() * 6000) * boneSpawnParams.cooldownMult;
                if (now - lastPowerupTime > baseCooldown) {
                    // Roll against spawn chance (higher score = lower chance)
                    if (Math.random() < boneSpawnParams.chance) {
                        // Step 2.7 powerup safety - find safe height BEFORE attempting spawn
                        const safeHeight = findSafeBoneHeight();
                        if (safeHeight !== null) {
                            // Step 2.7 powerup safety - pass the pre-validated safe height
                            if (spawnPowerup(safeHeight)) {
                                lastPowerupTime = now;
                            }
                        }
                    } else {
                        // Failed chance roll - still reset timer to avoid rapid re-checks
                        lastPowerupTime = now;
                    }
                }
                // Difficulty curve - smooth 3-act speed progression
                gameSpeed = calculateGameSpeed(score);
            }
            requestAnimationFrame(gameLoop);
        }

        // Step 3 sound - initialize audio on first user interaction
        // Desktop input - mousedown handler with UI checking (consistent with touch handlers)
        body.addEventListener('mousedown', e => {
            initAudio();
            if (isInputOnUI(e)) return; // Desktop input fix - never trigger jump on UI
            startJump();
        });
        // Desktop input - mouseup and mouseleave handlers
        body.addEventListener('mouseup', e => {
            if (isInputOnUI(e)) return;
            releaseJump();
        });
        body.addEventListener('mouseleave', releaseJump);
        // Mobile UI - mobile menu toggle functionality
        const mobileMenu = document.getElementById('mobileMenu');
        const moreBtn = document.getElementById('moreBtn');
        function toggleMobileMenu(e) {
            if (e) e.stopPropagation();
            mobileMenu.classList.toggle('show');
        }
        function closeMobileMenu() {
            mobileMenu.classList.remove('show');
        }
        // Mobile UI - close menu when clicking outside
        document.addEventListener('click', e => {
            if (!e.target.closest('.controls-wrapper')) closeMobileMenu();
        });
        document.addEventListener('touchstart', e => {
            if (!e.target.closest('.controls-wrapper') && !e.target.closest('.mobile-menu')) closeMobileMenu();
        }, { passive: true });

        // Gameplay polish - comprehensive UI selector to prevent jump on any UI element
        // Accessibility - includes toggle-switch for settings
        // Input fix - ensure .overlay-btn has proper dot prefix in selector
        // Note: .start-prompt and .hint are handled specially to allow game start
        const uiSelector = 'button, .btn, .overlay-btn, .overlay, .ui-top, .controls-wrapper, .mobile-menu, .lives-container, .score-display, .game-title, .about-btn, .version-string, .toggle-switch, label';
        // Gameplay polish - helper to check if input target is UI that should block input (works for both touch and mouse)
        function isInputOnUI(e) {
            // Ensure first gameplay input always starts the run:
            // During pre-run, allow clicks/touches on start-prompt and hint to pass through
            if (preRunState && !isAnyOverlayVisible()) {
                const onStartPrompt = e.target.closest('.start-prompt');
                const onHint = e.target.closest('.hint');
                if (onStartPrompt || onHint) {
                    return false; // Allow these inputs to trigger startJump
                }
            }
            return e.target.closest(uiSelector) !== null;
        }
        // Mobile input fix - touchstart handler ignores all UI elements
        body.addEventListener('touchstart', e => {
            initAudio();
            if (isInputOnUI(e)) return; // Input fix - never trigger jump on UI
            e.preventDefault();
            startJump();
        }, { passive: false });
        // Mobile input fix - touchend handler ignores all UI elements
        body.addEventListener('touchend', e => {
            if (isInputOnUI(e)) return; // Input fix - never trigger releaseJump on UI
            e.preventDefault();
            releaseJump();
        }, { passive: false });
        body.addEventListener('touchcancel', releaseJump);
        muteBtn.addEventListener('click', e => { e.stopPropagation(); initAudio(); toggleMute(); });
        document.getElementById('pauseBtn').addEventListener('click', e => { e.stopPropagation(); togglePause(); });
        document.getElementById('resetBtn').addEventListener('click', e => { e.stopPropagation(); resetGame(); });
        // Mobile UI - mobile reset button handler
        document.getElementById('resetBtnMobile').addEventListener('click', e => { e.stopPropagation(); closeMobileMenu(); resetGame(); });
        // Mobile UI - more menu button handler
        moreBtn.addEventListener('click', toggleMobileMenu);
        document.getElementById('resumeBtn').addEventListener('click', e => { e.stopPropagation(); togglePause(); });
        document.getElementById('restartBtn').addEventListener('click', e => { e.stopPropagation(); resetGame(); });
        // Game-over polish - Part E: Tap overlay background to restart
        gameOverOverlay.addEventListener('click', e => {
            // Only restart if clicking the overlay background, not the content or buttons
            if (e.target === gameOverOverlay || e.target.classList.contains('tap-hint')) {
                resetGame();
            }
        });
        // Step 4 tutorial - tutorial button event listener
        document.getElementById('tutorialBtn').addEventListener('click', e => { e.stopPropagation(); initAudio(); dismissTutorial(); });
        // Share polish - About button event listeners
        document.getElementById('aboutBtn').addEventListener('click', e => { e.stopPropagation(); showAbout(); });
        document.getElementById('aboutCloseBtn').addEventListener('click', e => { e.stopPropagation(); hideAbout(); });
        // Accessibility - Settings button event listeners
        document.getElementById('settingsBtnMobile').addEventListener('click', e => { e.stopPropagation(); closeMobileMenu(); showSettings(); });
        document.getElementById('settingsCloseBtn').addEventListener('click', e => { e.stopPropagation(); hideSettings(); });
        // UI polish - Help button in settings
        document.getElementById('helpBtn').addEventListener('click', e => { e.stopPropagation(); showHelp(); });

        // Accessibility - Keyboard support
        document.addEventListener('keydown', e => {
            // Ignore if typing in an input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            // Space or Enter: start jump (hold)
            if (e.code === 'Space' || e.code === 'Enter') {
                e.preventDefault();
                initAudio();
                startJump();
            }
            // P: toggle pause
            if (e.code === 'KeyP') {
                e.preventDefault();
                togglePause();
            }
            // R: restart game
            if (e.code === 'KeyR') {
                e.preventDefault();
                resetGame();
            }
            // Escape: close any open overlay
            if (e.code === 'Escape') {
                e.preventDefault();
                hideAbout();
                hideSettings();
                if (isPaused && !isGameOver) togglePause();
            }
        });

        document.addEventListener('keyup', e => {
            // Space or Enter: release jump
            if (e.code === 'Space' || e.code === 'Enter') {
                e.preventDefault();
                releaseJump();
            }
        });

        body.addEventListener('contextmenu', e => e.preventDefault());
        body.addEventListener('touchmove', e => e.preventDefault(), { passive: false });

        // Step 4 tutorial - show tutorial on first run, then start game loop
        // Visual hierarchy & pacing - Part B: Show start prompt if no tutorial
        generateBackground(); initLives();
        if (!tutorialActive) {
            startPrompt.classList.add('show');
        }
        showTutorial(); gameLoop();
 // --- SAFETY START FIX ---
document.addEventListener('pointerdown', (e) => {
  // ignore right-click / secondary button
  if (e.button !== undefined && e.button !== 0) return;

  if (typeof preRunState === 'undefined') return;

  if (preRunState && !isGameOver && !isPaused && !tutorialActive) {
    preRunState = false;
    document.body.classList.add('playing');
    if (typeof hideStartPrompt === 'function') hideStartPrompt();
  }
}, { once: true });

    </script>
</body>
</html>
